{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getFieldsWithDirectives = void 0;\nconst graphql_1 = require(\"graphql\");\nfunction parseDirectiveValue(value) {\n  switch (value.kind) {\n    case graphql_1.Kind.INT:\n      return parseInt(value.value);\n    case graphql_1.Kind.FLOAT:\n      return parseFloat(value.value);\n    case graphql_1.Kind.BOOLEAN:\n      return Boolean(value.value);\n    case graphql_1.Kind.STRING:\n    case graphql_1.Kind.ENUM:\n      return value.value;\n    case graphql_1.Kind.LIST:\n      return value.values.map(v => parseDirectiveValue(v));\n    case graphql_1.Kind.OBJECT:\n      return value.fields.reduce((prev, v) => ({\n        ...prev,\n        [v.name.value]: parseDirectiveValue(v.value)\n      }), {});\n    case graphql_1.Kind.NULL:\n      return null;\n    default:\n      return null;\n  }\n}\nfunction getFieldsWithDirectives(documentNode) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const result = {};\n  let selected = ['ObjectTypeDefinition', 'ObjectTypeExtension'];\n  if (options.includeInputTypes) {\n    selected = [...selected, 'InputObjectTypeDefinition', 'InputObjectTypeExtension'];\n  }\n  const allTypes = documentNode.definitions.filter(obj => selected.includes(obj.kind));\n  for (const type of allTypes) {\n    const typeName = type.name.value;\n    if (type.fields == null) {\n      continue;\n    }\n    for (const field of type.fields) {\n      if (field.directives && field.directives.length > 0) {\n        const fieldName = field.name.value;\n        const key = `${typeName}.${fieldName}`;\n        const directives = field.directives.map(d => ({\n          name: d.name.value,\n          args: (d.arguments || []).reduce((prev, arg) => ({\n            ...prev,\n            [arg.name.value]: parseDirectiveValue(arg.value)\n          }), {})\n        }));\n        result[key] = directives;\n      }\n    }\n  }\n  return result;\n}\nexports.getFieldsWithDirectives = getFieldsWithDirectives;","map":{"version":3,"names":["Object","defineProperty","exports","value","getFieldsWithDirectives","graphql_1","require","parseDirectiveValue","kind","Kind","INT","parseInt","FLOAT","parseFloat","BOOLEAN","Boolean","STRING","ENUM","LIST","values","map","v","OBJECT","fields","reduce","prev","name","NULL","documentNode","options","arguments","length","undefined","result","selected","includeInputTypes","allTypes","definitions","filter","obj","includes","type","typeName","field","directives","fieldName","key","d","args","arg"],"sources":["/Users/chadward/node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/get-fields-with-directives.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getFieldsWithDirectives = void 0;\nconst graphql_1 = require(\"graphql\");\nfunction parseDirectiveValue(value) {\n    switch (value.kind) {\n        case graphql_1.Kind.INT:\n            return parseInt(value.value);\n        case graphql_1.Kind.FLOAT:\n            return parseFloat(value.value);\n        case graphql_1.Kind.BOOLEAN:\n            return Boolean(value.value);\n        case graphql_1.Kind.STRING:\n        case graphql_1.Kind.ENUM:\n            return value.value;\n        case graphql_1.Kind.LIST:\n            return value.values.map(v => parseDirectiveValue(v));\n        case graphql_1.Kind.OBJECT:\n            return value.fields.reduce((prev, v) => ({ ...prev, [v.name.value]: parseDirectiveValue(v.value) }), {});\n        case graphql_1.Kind.NULL:\n            return null;\n        default:\n            return null;\n    }\n}\nfunction getFieldsWithDirectives(documentNode, options = {}) {\n    const result = {};\n    let selected = ['ObjectTypeDefinition', 'ObjectTypeExtension'];\n    if (options.includeInputTypes) {\n        selected = [...selected, 'InputObjectTypeDefinition', 'InputObjectTypeExtension'];\n    }\n    const allTypes = documentNode.definitions.filter(obj => selected.includes(obj.kind));\n    for (const type of allTypes) {\n        const typeName = type.name.value;\n        if (type.fields == null) {\n            continue;\n        }\n        for (const field of type.fields) {\n            if (field.directives && field.directives.length > 0) {\n                const fieldName = field.name.value;\n                const key = `${typeName}.${fieldName}`;\n                const directives = field.directives.map(d => ({\n                    name: d.name.value,\n                    args: (d.arguments || []).reduce((prev, arg) => ({ ...prev, [arg.name.value]: parseDirectiveValue(arg.value) }), {}),\n                }));\n                result[key] = directives;\n            }\n        }\n    }\n    return result;\n}\nexports.getFieldsWithDirectives = getFieldsWithDirectives;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}