{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.mergeDirective = exports.mergeDirectives = void 0;\nconst graphql_1 = require(\"graphql\");\nconst utils_1 = require(\"@graphql-tools/utils\");\nfunction directiveAlreadyExists(directivesArr, otherDirective) {\n  return !!directivesArr.find(directive => directive.name.value === otherDirective.name.value);\n}\nfunction nameAlreadyExists(name, namesArr) {\n  return namesArr.some(_ref => {\n    let {\n      value\n    } = _ref;\n    return value === name.value;\n  });\n}\nfunction mergeArguments(a1, a2) {\n  const result = [...a2];\n  for (const argument of a1) {\n    const existingIndex = result.findIndex(a => a.name.value === argument.name.value);\n    if (existingIndex > -1) {\n      const existingArg = result[existingIndex];\n      if (existingArg.value.kind === 'ListValue') {\n        const source = existingArg.value.values;\n        const target = argument.value.values;\n        // merge values of two lists\n        existingArg.value.values = deduplicateLists(source, target, (targetVal, source) => {\n          const value = targetVal.value;\n          return !value || !source.some(sourceVal => sourceVal.value === value);\n        });\n      } else {\n        existingArg.value = argument.value;\n      }\n    } else {\n      result.push(argument);\n    }\n  }\n  return result;\n}\nfunction deduplicateDirectives(directives) {\n  return directives.map((directive, i, all) => {\n    const firstAt = all.findIndex(d => d.name.value === directive.name.value);\n    if (firstAt !== i) {\n      const dup = all[firstAt];\n      directive.arguments = mergeArguments(directive.arguments, dup.arguments);\n      return null;\n    }\n    return directive;\n  }).filter(utils_1.isSome);\n}\nfunction mergeDirectives() {\n  let d1 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  let d2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  let config = arguments.length > 2 ? arguments[2] : undefined;\n  const reverseOrder = config && config.reverseDirectives;\n  const asNext = reverseOrder ? d1 : d2;\n  const asFirst = reverseOrder ? d2 : d1;\n  const result = deduplicateDirectives([...asNext]);\n  for (const directive of asFirst) {\n    if (directiveAlreadyExists(result, directive)) {\n      const existingDirectiveIndex = result.findIndex(d => d.name.value === directive.name.value);\n      const existingDirective = result[existingDirectiveIndex];\n      result[existingDirectiveIndex].arguments = mergeArguments(directive.arguments || [], existingDirective.arguments || []);\n    } else {\n      result.push(directive);\n    }\n  }\n  return result;\n}\nexports.mergeDirectives = mergeDirectives;\nfunction validateInputs(node, existingNode) {\n  const printedNode = (0, graphql_1.print)({\n    ...node,\n    description: undefined\n  });\n  const printedExistingNode = (0, graphql_1.print)({\n    ...existingNode,\n    description: undefined\n  });\n  // eslint-disable-next-line\n  const leaveInputs = new RegExp('(directive @w*d*)|( on .*$)', 'g');\n  const sameArguments = printedNode.replace(leaveInputs, '') === printedExistingNode.replace(leaveInputs, '');\n  if (!sameArguments) {\n    throw new Error(`Unable to merge GraphQL directive \"${node.name.value}\". \\nExisting directive:  \\n\\t${printedExistingNode} \\nReceived directive: \\n\\t${printedNode}`);\n  }\n}\nfunction mergeDirective(node, existingNode) {\n  if (existingNode) {\n    validateInputs(node, existingNode);\n    return {\n      ...node,\n      locations: [...existingNode.locations, ...node.locations.filter(name => !nameAlreadyExists(name, existingNode.locations))]\n    };\n  }\n  return node;\n}\nexports.mergeDirective = mergeDirective;\nfunction deduplicateLists(source, target, filterFn) {\n  return source.concat(target.filter(val => filterFn(val, source)));\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","mergeDirective","mergeDirectives","graphql_1","require","utils_1","directiveAlreadyExists","directivesArr","otherDirective","find","directive","name","nameAlreadyExists","namesArr","some","_ref","mergeArguments","a1","a2","result","argument","existingIndex","findIndex","a","existingArg","kind","source","values","target","deduplicateLists","targetVal","sourceVal","push","deduplicateDirectives","directives","map","i","all","firstAt","d","dup","arguments","filter","isSome","d1","length","undefined","d2","config","reverseOrder","reverseDirectives","asNext","asFirst","existingDirectiveIndex","existingDirective","validateInputs","node","existingNode","printedNode","print","description","printedExistingNode","leaveInputs","RegExp","sameArguments","replace","Error","locations","filterFn","concat","val"],"sources":["/Users/chadward/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/directives.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.mergeDirective = exports.mergeDirectives = void 0;\nconst graphql_1 = require(\"graphql\");\nconst utils_1 = require(\"@graphql-tools/utils\");\nfunction directiveAlreadyExists(directivesArr, otherDirective) {\n    return !!directivesArr.find(directive => directive.name.value === otherDirective.name.value);\n}\nfunction nameAlreadyExists(name, namesArr) {\n    return namesArr.some(({ value }) => value === name.value);\n}\nfunction mergeArguments(a1, a2) {\n    const result = [...a2];\n    for (const argument of a1) {\n        const existingIndex = result.findIndex(a => a.name.value === argument.name.value);\n        if (existingIndex > -1) {\n            const existingArg = result[existingIndex];\n            if (existingArg.value.kind === 'ListValue') {\n                const source = existingArg.value.values;\n                const target = argument.value.values;\n                // merge values of two lists\n                existingArg.value.values = deduplicateLists(source, target, (targetVal, source) => {\n                    const value = targetVal.value;\n                    return !value || !source.some((sourceVal) => sourceVal.value === value);\n                });\n            }\n            else {\n                existingArg.value = argument.value;\n            }\n        }\n        else {\n            result.push(argument);\n        }\n    }\n    return result;\n}\nfunction deduplicateDirectives(directives) {\n    return directives\n        .map((directive, i, all) => {\n        const firstAt = all.findIndex(d => d.name.value === directive.name.value);\n        if (firstAt !== i) {\n            const dup = all[firstAt];\n            directive.arguments = mergeArguments(directive.arguments, dup.arguments);\n            return null;\n        }\n        return directive;\n    })\n        .filter(utils_1.isSome);\n}\nfunction mergeDirectives(d1 = [], d2 = [], config) {\n    const reverseOrder = config && config.reverseDirectives;\n    const asNext = reverseOrder ? d1 : d2;\n    const asFirst = reverseOrder ? d2 : d1;\n    const result = deduplicateDirectives([...asNext]);\n    for (const directive of asFirst) {\n        if (directiveAlreadyExists(result, directive)) {\n            const existingDirectiveIndex = result.findIndex(d => d.name.value === directive.name.value);\n            const existingDirective = result[existingDirectiveIndex];\n            result[existingDirectiveIndex].arguments = mergeArguments(directive.arguments || [], existingDirective.arguments || []);\n        }\n        else {\n            result.push(directive);\n        }\n    }\n    return result;\n}\nexports.mergeDirectives = mergeDirectives;\nfunction validateInputs(node, existingNode) {\n    const printedNode = (0, graphql_1.print)({\n        ...node,\n        description: undefined,\n    });\n    const printedExistingNode = (0, graphql_1.print)({\n        ...existingNode,\n        description: undefined,\n    });\n    // eslint-disable-next-line\n    const leaveInputs = new RegExp('(directive @w*d*)|( on .*$)', 'g');\n    const sameArguments = printedNode.replace(leaveInputs, '') === printedExistingNode.replace(leaveInputs, '');\n    if (!sameArguments) {\n        throw new Error(`Unable to merge GraphQL directive \"${node.name.value}\". \\nExisting directive:  \\n\\t${printedExistingNode} \\nReceived directive: \\n\\t${printedNode}`);\n    }\n}\nfunction mergeDirective(node, existingNode) {\n    if (existingNode) {\n        validateInputs(node, existingNode);\n        return {\n            ...node,\n            locations: [\n                ...existingNode.locations,\n                ...node.locations.filter(name => !nameAlreadyExists(name, existingNode.locations)),\n            ],\n        };\n    }\n    return node;\n}\nexports.mergeDirective = mergeDirective;\nfunction deduplicateLists(source, target, filterFn) {\n    return source.concat(target.filter(val => filterFn(val, source)));\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}