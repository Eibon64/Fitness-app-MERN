{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.buildOperationNodeForField = void 0;\nconst graphql_1 = require(\"graphql\");\nconst rootTypes_js_1 = require(\"./rootTypes.js\");\nlet operationVariables = [];\nlet fieldTypeMap = new Map();\nfunction addOperationVariable(variable) {\n  operationVariables.push(variable);\n}\nfunction resetOperationVariables() {\n  operationVariables = [];\n}\nfunction resetFieldMap() {\n  fieldTypeMap = new Map();\n}\nfunction buildOperationNodeForField(_ref) {\n  let {\n    schema,\n    kind,\n    field,\n    models,\n    ignore = [],\n    depthLimit,\n    circularReferenceDepth,\n    argNames,\n    selectedFields = true\n  } = _ref;\n  resetOperationVariables();\n  resetFieldMap();\n  const rootTypeNames = (0, rootTypes_js_1.getRootTypeNames)(schema);\n  const operationNode = buildOperationAndCollectVariables({\n    schema,\n    fieldName: field,\n    kind,\n    models: models || [],\n    ignore,\n    depthLimit: depthLimit || Infinity,\n    circularReferenceDepth: circularReferenceDepth || 1,\n    argNames,\n    selectedFields,\n    rootTypeNames\n  });\n  // attach variables\n  operationNode.variableDefinitions = [...operationVariables];\n  resetOperationVariables();\n  resetFieldMap();\n  return operationNode;\n}\nexports.buildOperationNodeForField = buildOperationNodeForField;\nfunction buildOperationAndCollectVariables(_ref2) {\n  let {\n    schema,\n    fieldName,\n    kind,\n    models,\n    ignore,\n    depthLimit,\n    circularReferenceDepth,\n    argNames,\n    selectedFields,\n    rootTypeNames\n  } = _ref2;\n  const type = (0, rootTypes_js_1.getDefinedRootType)(schema, kind);\n  const field = type.getFields()[fieldName];\n  const operationName = `${fieldName}_${kind}`;\n  if (field.args) {\n    for (const arg of field.args) {\n      const argName = arg.name;\n      if (!argNames || argNames.includes(argName)) {\n        addOperationVariable(resolveVariable(arg, argName));\n      }\n    }\n  }\n  return {\n    kind: graphql_1.Kind.OPERATION_DEFINITION,\n    operation: kind,\n    name: {\n      kind: graphql_1.Kind.NAME,\n      value: operationName\n    },\n    variableDefinitions: [],\n    selectionSet: {\n      kind: graphql_1.Kind.SELECTION_SET,\n      selections: [resolveField({\n        type,\n        field,\n        models,\n        firstCall: true,\n        path: [],\n        ancestors: [],\n        ignore,\n        depthLimit,\n        circularReferenceDepth,\n        schema,\n        depth: 0,\n        argNames,\n        selectedFields,\n        rootTypeNames\n      })]\n    }\n  };\n}\nfunction resolveSelectionSet(_ref3) {\n  let {\n    parent,\n    type,\n    models,\n    firstCall,\n    path,\n    ancestors,\n    ignore,\n    depthLimit,\n    circularReferenceDepth,\n    schema,\n    depth,\n    argNames,\n    selectedFields,\n    rootTypeNames\n  } = _ref3;\n  if (typeof selectedFields === 'boolean' && depth > depthLimit) {\n    return;\n  }\n  if ((0, graphql_1.isUnionType)(type)) {\n    const types = type.getTypes();\n    return {\n      kind: graphql_1.Kind.SELECTION_SET,\n      selections: types.filter(t => !hasCircularRef([...ancestors, t], {\n        depth: circularReferenceDepth\n      })).map(t => {\n        return {\n          kind: graphql_1.Kind.INLINE_FRAGMENT,\n          typeCondition: {\n            kind: graphql_1.Kind.NAMED_TYPE,\n            name: {\n              kind: graphql_1.Kind.NAME,\n              value: t.name\n            }\n          },\n          selectionSet: resolveSelectionSet({\n            parent: type,\n            type: t,\n            models,\n            path,\n            ancestors,\n            ignore,\n            depthLimit,\n            circularReferenceDepth,\n            schema,\n            depth,\n            argNames,\n            selectedFields,\n            rootTypeNames\n          })\n        };\n      }).filter(fragmentNode => {\n        var _a, _b;\n        return ((_b = (_a = fragmentNode === null || fragmentNode === void 0 ? void 0 : fragmentNode.selectionSet) === null || _a === void 0 ? void 0 : _a.selections) === null || _b === void 0 ? void 0 : _b.length) > 0;\n      })\n    };\n  }\n  if ((0, graphql_1.isInterfaceType)(type)) {\n    const types = Object.values(schema.getTypeMap()).filter(t => (0, graphql_1.isObjectType)(t) && t.getInterfaces().includes(type));\n    return {\n      kind: graphql_1.Kind.SELECTION_SET,\n      selections: types.filter(t => !hasCircularRef([...ancestors, t], {\n        depth: circularReferenceDepth\n      })).map(t => {\n        return {\n          kind: graphql_1.Kind.INLINE_FRAGMENT,\n          typeCondition: {\n            kind: graphql_1.Kind.NAMED_TYPE,\n            name: {\n              kind: graphql_1.Kind.NAME,\n              value: t.name\n            }\n          },\n          selectionSet: resolveSelectionSet({\n            parent: type,\n            type: t,\n            models,\n            path,\n            ancestors,\n            ignore,\n            depthLimit,\n            circularReferenceDepth,\n            schema,\n            depth,\n            argNames,\n            selectedFields,\n            rootTypeNames\n          })\n        };\n      }).filter(fragmentNode => {\n        var _a, _b;\n        return ((_b = (_a = fragmentNode === null || fragmentNode === void 0 ? void 0 : fragmentNode.selectionSet) === null || _a === void 0 ? void 0 : _a.selections) === null || _b === void 0 ? void 0 : _b.length) > 0;\n      })\n    };\n  }\n  if ((0, graphql_1.isObjectType)(type) && !rootTypeNames.has(type.name)) {\n    const isIgnored = ignore.includes(type.name) || ignore.includes(`${parent.name}.${path[path.length - 1]}`);\n    const isModel = models.includes(type.name);\n    if (!firstCall && isModel && !isIgnored) {\n      return {\n        kind: graphql_1.Kind.SELECTION_SET,\n        selections: [{\n          kind: graphql_1.Kind.FIELD,\n          name: {\n            kind: graphql_1.Kind.NAME,\n            value: 'id'\n          }\n        }]\n      };\n    }\n    const fields = type.getFields();\n    return {\n      kind: graphql_1.Kind.SELECTION_SET,\n      selections: Object.keys(fields).filter(fieldName => {\n        return !hasCircularRef([...ancestors, (0, graphql_1.getNamedType)(fields[fieldName].type)], {\n          depth: circularReferenceDepth\n        });\n      }).map(fieldName => {\n        const selectedSubFields = typeof selectedFields === 'object' ? selectedFields[fieldName] : true;\n        if (selectedSubFields) {\n          return resolveField({\n            type,\n            field: fields[fieldName],\n            models,\n            path: [...path, fieldName],\n            ancestors,\n            ignore,\n            depthLimit,\n            circularReferenceDepth,\n            schema,\n            depth,\n            argNames,\n            selectedFields: selectedSubFields,\n            rootTypeNames\n          });\n        }\n        return null;\n      }).filter(f => {\n        var _a, _b;\n        if (f == null) {\n          return false;\n        } else if ('selectionSet' in f) {\n          return !!((_b = (_a = f.selectionSet) === null || _a === void 0 ? void 0 : _a.selections) === null || _b === void 0 ? void 0 : _b.length);\n        }\n        return true;\n      })\n    };\n  }\n}\nfunction resolveVariable(arg, name) {\n  function resolveVariableType(type) {\n    if ((0, graphql_1.isListType)(type)) {\n      return {\n        kind: graphql_1.Kind.LIST_TYPE,\n        type: resolveVariableType(type.ofType)\n      };\n    }\n    if ((0, graphql_1.isNonNullType)(type)) {\n      return {\n        kind: graphql_1.Kind.NON_NULL_TYPE,\n        // for v16 compatibility\n        type: resolveVariableType(type.ofType)\n      };\n    }\n    return {\n      kind: graphql_1.Kind.NAMED_TYPE,\n      name: {\n        kind: graphql_1.Kind.NAME,\n        value: type.name\n      }\n    };\n  }\n  return {\n    kind: graphql_1.Kind.VARIABLE_DEFINITION,\n    variable: {\n      kind: graphql_1.Kind.VARIABLE,\n      name: {\n        kind: graphql_1.Kind.NAME,\n        value: name || arg.name\n      }\n    },\n    type: resolveVariableType(arg.type)\n  };\n}\nfunction getArgumentName(name, path) {\n  return [...path, name].join('_');\n}\nfunction resolveField(_ref4) {\n  let {\n    type,\n    field,\n    models,\n    firstCall,\n    path,\n    ancestors,\n    ignore,\n    depthLimit,\n    circularReferenceDepth,\n    schema,\n    depth,\n    argNames,\n    selectedFields,\n    rootTypeNames\n  } = _ref4;\n  const namedType = (0, graphql_1.getNamedType)(field.type);\n  let args = [];\n  let removeField = false;\n  if (field.args && field.args.length) {\n    args = field.args.map(arg => {\n      const argumentName = getArgumentName(arg.name, path);\n      if (argNames && !argNames.includes(argumentName)) {\n        if ((0, graphql_1.isNonNullType)(arg.type)) {\n          removeField = true;\n        }\n        return null;\n      }\n      if (!firstCall) {\n        addOperationVariable(resolveVariable(arg, argumentName));\n      }\n      return {\n        kind: graphql_1.Kind.ARGUMENT,\n        name: {\n          kind: graphql_1.Kind.NAME,\n          value: arg.name\n        },\n        value: {\n          kind: graphql_1.Kind.VARIABLE,\n          name: {\n            kind: graphql_1.Kind.NAME,\n            value: getArgumentName(arg.name, path)\n          }\n        }\n      };\n    }).filter(Boolean);\n  }\n  if (removeField) {\n    return null;\n  }\n  const fieldPath = [...path, field.name];\n  const fieldPathStr = fieldPath.join('.');\n  let fieldName = field.name;\n  if (fieldTypeMap.has(fieldPathStr) && fieldTypeMap.get(fieldPathStr) !== field.type.toString()) {\n    fieldName += field.type.toString().replace('!', 'NonNull').replace('[', 'List').replace(']', '');\n  }\n  fieldTypeMap.set(fieldPathStr, field.type.toString());\n  if (!(0, graphql_1.isScalarType)(namedType) && !(0, graphql_1.isEnumType)(namedType)) {\n    return {\n      kind: graphql_1.Kind.FIELD,\n      name: {\n        kind: graphql_1.Kind.NAME,\n        value: field.name\n      },\n      ...(fieldName !== field.name && {\n        alias: {\n          kind: graphql_1.Kind.NAME,\n          value: fieldName\n        }\n      }),\n      selectionSet: resolveSelectionSet({\n        parent: type,\n        type: namedType,\n        models,\n        firstCall,\n        path: fieldPath,\n        ancestors: [...ancestors, type],\n        ignore,\n        depthLimit,\n        circularReferenceDepth,\n        schema,\n        depth: depth + 1,\n        argNames,\n        selectedFields,\n        rootTypeNames\n      }) || undefined,\n      arguments: args\n    };\n  }\n  return {\n    kind: graphql_1.Kind.FIELD,\n    name: {\n      kind: graphql_1.Kind.NAME,\n      value: field.name\n    },\n    ...(fieldName !== field.name && {\n      alias: {\n        kind: graphql_1.Kind.NAME,\n        value: fieldName\n      }\n    }),\n    arguments: args\n  };\n}\nfunction hasCircularRef(types) {\n  let config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n    depth: 1\n  };\n  const type = types[types.length - 1];\n  if ((0, graphql_1.isScalarType)(type)) {\n    return false;\n  }\n  const size = types.filter(t => t.name === type.name).length;\n  return size > config.depth;\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","buildOperationNodeForField","graphql_1","require","rootTypes_js_1","operationVariables","fieldTypeMap","Map","addOperationVariable","variable","push","resetOperationVariables","resetFieldMap","_ref","schema","kind","field","models","ignore","depthLimit","circularReferenceDepth","argNames","selectedFields","rootTypeNames","getRootTypeNames","operationNode","buildOperationAndCollectVariables","fieldName","Infinity","variableDefinitions","_ref2","type","getDefinedRootType","getFields","operationName","args","arg","argName","name","includes","resolveVariable","Kind","OPERATION_DEFINITION","operation","NAME","selectionSet","SELECTION_SET","selections","resolveField","firstCall","path","ancestors","depth","resolveSelectionSet","_ref3","parent","isUnionType","types","getTypes","filter","t","hasCircularRef","map","INLINE_FRAGMENT","typeCondition","NAMED_TYPE","fragmentNode","_a","_b","length","isInterfaceType","values","getTypeMap","isObjectType","getInterfaces","has","isIgnored","isModel","FIELD","fields","keys","getNamedType","selectedSubFields","f","resolveVariableType","isListType","LIST_TYPE","ofType","isNonNullType","NON_NULL_TYPE","VARIABLE_DEFINITION","VARIABLE","getArgumentName","join","_ref4","namedType","removeField","argumentName","ARGUMENT","Boolean","fieldPath","fieldPathStr","get","toString","replace","set","isScalarType","isEnumType","alias","undefined","arguments","config","size"],"sources":["/Users/chadward/node_modules/@graphql-tools/utils/cjs/build-operation-for-field.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.buildOperationNodeForField = void 0;\nconst graphql_1 = require(\"graphql\");\nconst rootTypes_js_1 = require(\"./rootTypes.js\");\nlet operationVariables = [];\nlet fieldTypeMap = new Map();\nfunction addOperationVariable(variable) {\n    operationVariables.push(variable);\n}\nfunction resetOperationVariables() {\n    operationVariables = [];\n}\nfunction resetFieldMap() {\n    fieldTypeMap = new Map();\n}\nfunction buildOperationNodeForField({ schema, kind, field, models, ignore = [], depthLimit, circularReferenceDepth, argNames, selectedFields = true, }) {\n    resetOperationVariables();\n    resetFieldMap();\n    const rootTypeNames = (0, rootTypes_js_1.getRootTypeNames)(schema);\n    const operationNode = buildOperationAndCollectVariables({\n        schema,\n        fieldName: field,\n        kind,\n        models: models || [],\n        ignore,\n        depthLimit: depthLimit || Infinity,\n        circularReferenceDepth: circularReferenceDepth || 1,\n        argNames,\n        selectedFields,\n        rootTypeNames,\n    });\n    // attach variables\n    operationNode.variableDefinitions = [...operationVariables];\n    resetOperationVariables();\n    resetFieldMap();\n    return operationNode;\n}\nexports.buildOperationNodeForField = buildOperationNodeForField;\nfunction buildOperationAndCollectVariables({ schema, fieldName, kind, models, ignore, depthLimit, circularReferenceDepth, argNames, selectedFields, rootTypeNames, }) {\n    const type = (0, rootTypes_js_1.getDefinedRootType)(schema, kind);\n    const field = type.getFields()[fieldName];\n    const operationName = `${fieldName}_${kind}`;\n    if (field.args) {\n        for (const arg of field.args) {\n            const argName = arg.name;\n            if (!argNames || argNames.includes(argName)) {\n                addOperationVariable(resolveVariable(arg, argName));\n            }\n        }\n    }\n    return {\n        kind: graphql_1.Kind.OPERATION_DEFINITION,\n        operation: kind,\n        name: {\n            kind: graphql_1.Kind.NAME,\n            value: operationName,\n        },\n        variableDefinitions: [],\n        selectionSet: {\n            kind: graphql_1.Kind.SELECTION_SET,\n            selections: [\n                resolveField({\n                    type,\n                    field,\n                    models,\n                    firstCall: true,\n                    path: [],\n                    ancestors: [],\n                    ignore,\n                    depthLimit,\n                    circularReferenceDepth,\n                    schema,\n                    depth: 0,\n                    argNames,\n                    selectedFields,\n                    rootTypeNames,\n                }),\n            ],\n        },\n    };\n}\nfunction resolveSelectionSet({ parent, type, models, firstCall, path, ancestors, ignore, depthLimit, circularReferenceDepth, schema, depth, argNames, selectedFields, rootTypeNames, }) {\n    if (typeof selectedFields === 'boolean' && depth > depthLimit) {\n        return;\n    }\n    if ((0, graphql_1.isUnionType)(type)) {\n        const types = type.getTypes();\n        return {\n            kind: graphql_1.Kind.SELECTION_SET,\n            selections: types\n                .filter(t => !hasCircularRef([...ancestors, t], {\n                depth: circularReferenceDepth,\n            }))\n                .map(t => {\n                return {\n                    kind: graphql_1.Kind.INLINE_FRAGMENT,\n                    typeCondition: {\n                        kind: graphql_1.Kind.NAMED_TYPE,\n                        name: {\n                            kind: graphql_1.Kind.NAME,\n                            value: t.name,\n                        },\n                    },\n                    selectionSet: resolveSelectionSet({\n                        parent: type,\n                        type: t,\n                        models,\n                        path,\n                        ancestors,\n                        ignore,\n                        depthLimit,\n                        circularReferenceDepth,\n                        schema,\n                        depth,\n                        argNames,\n                        selectedFields,\n                        rootTypeNames,\n                    }),\n                };\n            })\n                .filter(fragmentNode => { var _a, _b; return ((_b = (_a = fragmentNode === null || fragmentNode === void 0 ? void 0 : fragmentNode.selectionSet) === null || _a === void 0 ? void 0 : _a.selections) === null || _b === void 0 ? void 0 : _b.length) > 0; }),\n        };\n    }\n    if ((0, graphql_1.isInterfaceType)(type)) {\n        const types = Object.values(schema.getTypeMap()).filter((t) => (0, graphql_1.isObjectType)(t) && t.getInterfaces().includes(type));\n        return {\n            kind: graphql_1.Kind.SELECTION_SET,\n            selections: types\n                .filter(t => !hasCircularRef([...ancestors, t], {\n                depth: circularReferenceDepth,\n            }))\n                .map(t => {\n                return {\n                    kind: graphql_1.Kind.INLINE_FRAGMENT,\n                    typeCondition: {\n                        kind: graphql_1.Kind.NAMED_TYPE,\n                        name: {\n                            kind: graphql_1.Kind.NAME,\n                            value: t.name,\n                        },\n                    },\n                    selectionSet: resolveSelectionSet({\n                        parent: type,\n                        type: t,\n                        models,\n                        path,\n                        ancestors,\n                        ignore,\n                        depthLimit,\n                        circularReferenceDepth,\n                        schema,\n                        depth,\n                        argNames,\n                        selectedFields,\n                        rootTypeNames,\n                    }),\n                };\n            })\n                .filter(fragmentNode => { var _a, _b; return ((_b = (_a = fragmentNode === null || fragmentNode === void 0 ? void 0 : fragmentNode.selectionSet) === null || _a === void 0 ? void 0 : _a.selections) === null || _b === void 0 ? void 0 : _b.length) > 0; }),\n        };\n    }\n    if ((0, graphql_1.isObjectType)(type) && !rootTypeNames.has(type.name)) {\n        const isIgnored = ignore.includes(type.name) || ignore.includes(`${parent.name}.${path[path.length - 1]}`);\n        const isModel = models.includes(type.name);\n        if (!firstCall && isModel && !isIgnored) {\n            return {\n                kind: graphql_1.Kind.SELECTION_SET,\n                selections: [\n                    {\n                        kind: graphql_1.Kind.FIELD,\n                        name: {\n                            kind: graphql_1.Kind.NAME,\n                            value: 'id',\n                        },\n                    },\n                ],\n            };\n        }\n        const fields = type.getFields();\n        return {\n            kind: graphql_1.Kind.SELECTION_SET,\n            selections: Object.keys(fields)\n                .filter(fieldName => {\n                return !hasCircularRef([...ancestors, (0, graphql_1.getNamedType)(fields[fieldName].type)], {\n                    depth: circularReferenceDepth,\n                });\n            })\n                .map(fieldName => {\n                const selectedSubFields = typeof selectedFields === 'object' ? selectedFields[fieldName] : true;\n                if (selectedSubFields) {\n                    return resolveField({\n                        type,\n                        field: fields[fieldName],\n                        models,\n                        path: [...path, fieldName],\n                        ancestors,\n                        ignore,\n                        depthLimit,\n                        circularReferenceDepth,\n                        schema,\n                        depth,\n                        argNames,\n                        selectedFields: selectedSubFields,\n                        rootTypeNames,\n                    });\n                }\n                return null;\n            })\n                .filter((f) => {\n                var _a, _b;\n                if (f == null) {\n                    return false;\n                }\n                else if ('selectionSet' in f) {\n                    return !!((_b = (_a = f.selectionSet) === null || _a === void 0 ? void 0 : _a.selections) === null || _b === void 0 ? void 0 : _b.length);\n                }\n                return true;\n            }),\n        };\n    }\n}\nfunction resolveVariable(arg, name) {\n    function resolveVariableType(type) {\n        if ((0, graphql_1.isListType)(type)) {\n            return {\n                kind: graphql_1.Kind.LIST_TYPE,\n                type: resolveVariableType(type.ofType),\n            };\n        }\n        if ((0, graphql_1.isNonNullType)(type)) {\n            return {\n                kind: graphql_1.Kind.NON_NULL_TYPE,\n                // for v16 compatibility\n                type: resolveVariableType(type.ofType),\n            };\n        }\n        return {\n            kind: graphql_1.Kind.NAMED_TYPE,\n            name: {\n                kind: graphql_1.Kind.NAME,\n                value: type.name,\n            },\n        };\n    }\n    return {\n        kind: graphql_1.Kind.VARIABLE_DEFINITION,\n        variable: {\n            kind: graphql_1.Kind.VARIABLE,\n            name: {\n                kind: graphql_1.Kind.NAME,\n                value: name || arg.name,\n            },\n        },\n        type: resolveVariableType(arg.type),\n    };\n}\nfunction getArgumentName(name, path) {\n    return [...path, name].join('_');\n}\nfunction resolveField({ type, field, models, firstCall, path, ancestors, ignore, depthLimit, circularReferenceDepth, schema, depth, argNames, selectedFields, rootTypeNames, }) {\n    const namedType = (0, graphql_1.getNamedType)(field.type);\n    let args = [];\n    let removeField = false;\n    if (field.args && field.args.length) {\n        args = field.args\n            .map(arg => {\n            const argumentName = getArgumentName(arg.name, path);\n            if (argNames && !argNames.includes(argumentName)) {\n                if ((0, graphql_1.isNonNullType)(arg.type)) {\n                    removeField = true;\n                }\n                return null;\n            }\n            if (!firstCall) {\n                addOperationVariable(resolveVariable(arg, argumentName));\n            }\n            return {\n                kind: graphql_1.Kind.ARGUMENT,\n                name: {\n                    kind: graphql_1.Kind.NAME,\n                    value: arg.name,\n                },\n                value: {\n                    kind: graphql_1.Kind.VARIABLE,\n                    name: {\n                        kind: graphql_1.Kind.NAME,\n                        value: getArgumentName(arg.name, path),\n                    },\n                },\n            };\n        })\n            .filter(Boolean);\n    }\n    if (removeField) {\n        return null;\n    }\n    const fieldPath = [...path, field.name];\n    const fieldPathStr = fieldPath.join('.');\n    let fieldName = field.name;\n    if (fieldTypeMap.has(fieldPathStr) && fieldTypeMap.get(fieldPathStr) !== field.type.toString()) {\n        fieldName += field.type.toString().replace('!', 'NonNull').replace('[', 'List').replace(']', '');\n    }\n    fieldTypeMap.set(fieldPathStr, field.type.toString());\n    if (!(0, graphql_1.isScalarType)(namedType) && !(0, graphql_1.isEnumType)(namedType)) {\n        return {\n            kind: graphql_1.Kind.FIELD,\n            name: {\n                kind: graphql_1.Kind.NAME,\n                value: field.name,\n            },\n            ...(fieldName !== field.name && { alias: { kind: graphql_1.Kind.NAME, value: fieldName } }),\n            selectionSet: resolveSelectionSet({\n                parent: type,\n                type: namedType,\n                models,\n                firstCall,\n                path: fieldPath,\n                ancestors: [...ancestors, type],\n                ignore,\n                depthLimit,\n                circularReferenceDepth,\n                schema,\n                depth: depth + 1,\n                argNames,\n                selectedFields,\n                rootTypeNames,\n            }) || undefined,\n            arguments: args,\n        };\n    }\n    return {\n        kind: graphql_1.Kind.FIELD,\n        name: {\n            kind: graphql_1.Kind.NAME,\n            value: field.name,\n        },\n        ...(fieldName !== field.name && { alias: { kind: graphql_1.Kind.NAME, value: fieldName } }),\n        arguments: args,\n    };\n}\nfunction hasCircularRef(types, config = {\n    depth: 1,\n}) {\n    const type = types[types.length - 1];\n    if ((0, graphql_1.isScalarType)(type)) {\n        return false;\n    }\n    const size = types.filter(t => t.name === type.name).length;\n    return size > config.depth;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}