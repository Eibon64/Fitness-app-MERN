{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isDescribable = exports.transformCommentsToDescriptions = exports.parseGraphQLSDL = void 0;\nconst graphql_1 = require(\"graphql\");\nconst comments_js_1 = require(\"./comments.js\");\nfunction parseGraphQLSDL(location, rawSDL) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  let document;\n  try {\n    if (options.commentDescriptions && rawSDL.includes('#')) {\n      document = transformCommentsToDescriptions(rawSDL, options);\n      // If noLocation=true, we need to make sure to print and parse it again, to remove locations,\n      // since `transformCommentsToDescriptions` must have locations set in order to transform the comments\n      // into descriptions.\n      if (options.noLocation) {\n        document = (0, graphql_1.parse)((0, graphql_1.print)(document), options);\n      }\n    } else {\n      document = (0, graphql_1.parse)(new graphql_1.Source(rawSDL, location), options);\n    }\n  } catch (e) {\n    if (e.message.includes('EOF') && rawSDL.replace(/(\\#[^*]*)/g, '').trim() === '') {\n      document = {\n        kind: graphql_1.Kind.DOCUMENT,\n        definitions: []\n      };\n    } else {\n      throw e;\n    }\n  }\n  return {\n    location,\n    document\n  };\n}\nexports.parseGraphQLSDL = parseGraphQLSDL;\nfunction transformCommentsToDescriptions(sourceSdl) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const parsedDoc = (0, graphql_1.parse)(sourceSdl, {\n    ...options,\n    noLocation: false\n  });\n  const modifiedDoc = (0, graphql_1.visit)(parsedDoc, {\n    leave: node => {\n      if (isDescribable(node)) {\n        const rawValue = (0, comments_js_1.getLeadingCommentBlock)(node);\n        if (rawValue !== undefined) {\n          const commentsBlock = (0, comments_js_1.dedentBlockStringValue)('\\n' + rawValue);\n          const isBlock = commentsBlock.includes('\\n');\n          if (!node.description) {\n            return {\n              ...node,\n              description: {\n                kind: graphql_1.Kind.STRING,\n                value: commentsBlock,\n                block: isBlock\n              }\n            };\n          } else {\n            return {\n              ...node,\n              description: {\n                ...node.description,\n                value: node.description.value + '\\n' + commentsBlock,\n                block: true\n              }\n            };\n          }\n        }\n      }\n    }\n  });\n  return modifiedDoc;\n}\nexports.transformCommentsToDescriptions = transformCommentsToDescriptions;\nfunction isDescribable(node) {\n  return (0, graphql_1.isTypeSystemDefinitionNode)(node) || node.kind === graphql_1.Kind.FIELD_DEFINITION || node.kind === graphql_1.Kind.INPUT_VALUE_DEFINITION || node.kind === graphql_1.Kind.ENUM_VALUE_DEFINITION;\n}\nexports.isDescribable = isDescribable;","map":{"version":3,"names":["Object","defineProperty","exports","value","isDescribable","transformCommentsToDescriptions","parseGraphQLSDL","graphql_1","require","comments_js_1","location","rawSDL","options","arguments","length","undefined","document","commentDescriptions","includes","noLocation","parse","print","Source","e","message","replace","trim","kind","Kind","DOCUMENT","definitions","sourceSdl","parsedDoc","modifiedDoc","visit","leave","node","rawValue","getLeadingCommentBlock","commentsBlock","dedentBlockStringValue","isBlock","description","STRING","block","isTypeSystemDefinitionNode","FIELD_DEFINITION","INPUT_VALUE_DEFINITION","ENUM_VALUE_DEFINITION"],"sources":["/Users/chadward/node_modules/@graphql-tools/utils/cjs/parse-graphql-sdl.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isDescribable = exports.transformCommentsToDescriptions = exports.parseGraphQLSDL = void 0;\nconst graphql_1 = require(\"graphql\");\nconst comments_js_1 = require(\"./comments.js\");\nfunction parseGraphQLSDL(location, rawSDL, options = {}) {\n    let document;\n    try {\n        if (options.commentDescriptions && rawSDL.includes('#')) {\n            document = transformCommentsToDescriptions(rawSDL, options);\n            // If noLocation=true, we need to make sure to print and parse it again, to remove locations,\n            // since `transformCommentsToDescriptions` must have locations set in order to transform the comments\n            // into descriptions.\n            if (options.noLocation) {\n                document = (0, graphql_1.parse)((0, graphql_1.print)(document), options);\n            }\n        }\n        else {\n            document = (0, graphql_1.parse)(new graphql_1.Source(rawSDL, location), options);\n        }\n    }\n    catch (e) {\n        if (e.message.includes('EOF') && rawSDL.replace(/(\\#[^*]*)/g, '').trim() === '') {\n            document = {\n                kind: graphql_1.Kind.DOCUMENT,\n                definitions: [],\n            };\n        }\n        else {\n            throw e;\n        }\n    }\n    return {\n        location,\n        document,\n    };\n}\nexports.parseGraphQLSDL = parseGraphQLSDL;\nfunction transformCommentsToDescriptions(sourceSdl, options = {}) {\n    const parsedDoc = (0, graphql_1.parse)(sourceSdl, {\n        ...options,\n        noLocation: false,\n    });\n    const modifiedDoc = (0, graphql_1.visit)(parsedDoc, {\n        leave: (node) => {\n            if (isDescribable(node)) {\n                const rawValue = (0, comments_js_1.getLeadingCommentBlock)(node);\n                if (rawValue !== undefined) {\n                    const commentsBlock = (0, comments_js_1.dedentBlockStringValue)('\\n' + rawValue);\n                    const isBlock = commentsBlock.includes('\\n');\n                    if (!node.description) {\n                        return {\n                            ...node,\n                            description: {\n                                kind: graphql_1.Kind.STRING,\n                                value: commentsBlock,\n                                block: isBlock,\n                            },\n                        };\n                    }\n                    else {\n                        return {\n                            ...node,\n                            description: {\n                                ...node.description,\n                                value: node.description.value + '\\n' + commentsBlock,\n                                block: true,\n                            },\n                        };\n                    }\n                }\n            }\n        },\n    });\n    return modifiedDoc;\n}\nexports.transformCommentsToDescriptions = transformCommentsToDescriptions;\nfunction isDescribable(node) {\n    return ((0, graphql_1.isTypeSystemDefinitionNode)(node) ||\n        node.kind === graphql_1.Kind.FIELD_DEFINITION ||\n        node.kind === graphql_1.Kind.INPUT_VALUE_DEFINITION ||\n        node.kind === graphql_1.Kind.ENUM_VALUE_DEFINITION);\n}\nexports.isDescribable = isDescribable;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}