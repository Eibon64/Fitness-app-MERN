{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.correctASTNodes = exports.mapSchema = void 0;\nconst graphql_1 = require(\"graphql\");\nconst getObjectTypeFromTypeMap_js_1 = require(\"./getObjectTypeFromTypeMap.js\");\nconst Interfaces_js_1 = require(\"./Interfaces.js\");\nconst rewire_js_1 = require(\"./rewire.js\");\nconst transformInputValue_js_1 = require(\"./transformInputValue.js\");\nfunction mapSchema(schema) {\n  let schemaMapper = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const newTypeMap = mapArguments(mapFields(mapTypes(mapDefaultValues(mapEnumValues(mapTypes(mapDefaultValues(schema.getTypeMap(), schema, transformInputValue_js_1.serializeInputValue), schema, schemaMapper, type => (0, graphql_1.isLeafType)(type)), schema, schemaMapper), schema, transformInputValue_js_1.parseInputValue), schema, schemaMapper, type => !(0, graphql_1.isLeafType)(type)), schema, schemaMapper), schema, schemaMapper);\n  const originalDirectives = schema.getDirectives();\n  const newDirectives = mapDirectives(originalDirectives, schema, schemaMapper);\n  const {\n    typeMap,\n    directives\n  } = (0, rewire_js_1.rewireTypes)(newTypeMap, newDirectives);\n  return new graphql_1.GraphQLSchema({\n    ...schema.toConfig(),\n    query: (0, getObjectTypeFromTypeMap_js_1.getObjectTypeFromTypeMap)(typeMap, (0, getObjectTypeFromTypeMap_js_1.getObjectTypeFromTypeMap)(newTypeMap, schema.getQueryType())),\n    mutation: (0, getObjectTypeFromTypeMap_js_1.getObjectTypeFromTypeMap)(typeMap, (0, getObjectTypeFromTypeMap_js_1.getObjectTypeFromTypeMap)(newTypeMap, schema.getMutationType())),\n    subscription: (0, getObjectTypeFromTypeMap_js_1.getObjectTypeFromTypeMap)(typeMap, (0, getObjectTypeFromTypeMap_js_1.getObjectTypeFromTypeMap)(newTypeMap, schema.getSubscriptionType())),\n    types: Object.values(typeMap),\n    directives\n  });\n}\nexports.mapSchema = mapSchema;\nfunction mapTypes(originalTypeMap, schema, schemaMapper) {\n  let testFn = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : () => true;\n  const newTypeMap = {};\n  for (const typeName in originalTypeMap) {\n    if (!typeName.startsWith('__')) {\n      const originalType = originalTypeMap[typeName];\n      if (originalType == null || !testFn(originalType)) {\n        newTypeMap[typeName] = originalType;\n        continue;\n      }\n      const typeMapper = getTypeMapper(schema, schemaMapper, typeName);\n      if (typeMapper == null) {\n        newTypeMap[typeName] = originalType;\n        continue;\n      }\n      const maybeNewType = typeMapper(originalType, schema);\n      if (maybeNewType === undefined) {\n        newTypeMap[typeName] = originalType;\n        continue;\n      }\n      newTypeMap[typeName] = maybeNewType;\n    }\n  }\n  return newTypeMap;\n}\nfunction mapEnumValues(originalTypeMap, schema, schemaMapper) {\n  const enumValueMapper = getEnumValueMapper(schemaMapper);\n  if (!enumValueMapper) {\n    return originalTypeMap;\n  }\n  return mapTypes(originalTypeMap, schema, {\n    [Interfaces_js_1.MapperKind.ENUM_TYPE]: type => {\n      const config = type.toConfig();\n      const originalEnumValueConfigMap = config.values;\n      const newEnumValueConfigMap = {};\n      for (const externalValue in originalEnumValueConfigMap) {\n        const originalEnumValueConfig = originalEnumValueConfigMap[externalValue];\n        const mappedEnumValue = enumValueMapper(originalEnumValueConfig, type.name, schema, externalValue);\n        if (mappedEnumValue === undefined) {\n          newEnumValueConfigMap[externalValue] = originalEnumValueConfig;\n        } else if (Array.isArray(mappedEnumValue)) {\n          const [newExternalValue, newEnumValueConfig] = mappedEnumValue;\n          newEnumValueConfigMap[newExternalValue] = newEnumValueConfig === undefined ? originalEnumValueConfig : newEnumValueConfig;\n        } else if (mappedEnumValue !== null) {\n          newEnumValueConfigMap[externalValue] = mappedEnumValue;\n        }\n      }\n      return correctASTNodes(new graphql_1.GraphQLEnumType({\n        ...config,\n        values: newEnumValueConfigMap\n      }));\n    }\n  }, type => (0, graphql_1.isEnumType)(type));\n}\nfunction mapDefaultValues(originalTypeMap, schema, fn) {\n  const newTypeMap = mapArguments(originalTypeMap, schema, {\n    [Interfaces_js_1.MapperKind.ARGUMENT]: argumentConfig => {\n      if (argumentConfig.defaultValue === undefined) {\n        return argumentConfig;\n      }\n      const maybeNewType = getNewType(originalTypeMap, argumentConfig.type);\n      if (maybeNewType != null) {\n        return {\n          ...argumentConfig,\n          defaultValue: fn(maybeNewType, argumentConfig.defaultValue)\n        };\n      }\n    }\n  });\n  return mapFields(newTypeMap, schema, {\n    [Interfaces_js_1.MapperKind.INPUT_OBJECT_FIELD]: inputFieldConfig => {\n      if (inputFieldConfig.defaultValue === undefined) {\n        return inputFieldConfig;\n      }\n      const maybeNewType = getNewType(newTypeMap, inputFieldConfig.type);\n      if (maybeNewType != null) {\n        return {\n          ...inputFieldConfig,\n          defaultValue: fn(maybeNewType, inputFieldConfig.defaultValue)\n        };\n      }\n    }\n  });\n}\nfunction getNewType(newTypeMap, type) {\n  if ((0, graphql_1.isListType)(type)) {\n    const newType = getNewType(newTypeMap, type.ofType);\n    return newType != null ? new graphql_1.GraphQLList(newType) : null;\n  } else if ((0, graphql_1.isNonNullType)(type)) {\n    const newType = getNewType(newTypeMap, type.ofType);\n    return newType != null ? new graphql_1.GraphQLNonNull(newType) : null;\n  } else if ((0, graphql_1.isNamedType)(type)) {\n    const newType = newTypeMap[type.name];\n    return newType != null ? newType : null;\n  }\n  return null;\n}\nfunction mapFields(originalTypeMap, schema, schemaMapper) {\n  const newTypeMap = {};\n  for (const typeName in originalTypeMap) {\n    if (!typeName.startsWith('__')) {\n      const originalType = originalTypeMap[typeName];\n      if (!(0, graphql_1.isObjectType)(originalType) && !(0, graphql_1.isInterfaceType)(originalType) && !(0, graphql_1.isInputObjectType)(originalType)) {\n        newTypeMap[typeName] = originalType;\n        continue;\n      }\n      const fieldMapper = getFieldMapper(schema, schemaMapper, typeName);\n      if (fieldMapper == null) {\n        newTypeMap[typeName] = originalType;\n        continue;\n      }\n      const config = originalType.toConfig();\n      const originalFieldConfigMap = config.fields;\n      const newFieldConfigMap = {};\n      for (const fieldName in originalFieldConfigMap) {\n        const originalFieldConfig = originalFieldConfigMap[fieldName];\n        const mappedField = fieldMapper(originalFieldConfig, fieldName, typeName, schema);\n        if (mappedField === undefined) {\n          newFieldConfigMap[fieldName] = originalFieldConfig;\n        } else if (Array.isArray(mappedField)) {\n          const [newFieldName, newFieldConfig] = mappedField;\n          if (newFieldConfig.astNode != null) {\n            newFieldConfig.astNode = {\n              ...newFieldConfig.astNode,\n              name: {\n                ...newFieldConfig.astNode.name,\n                value: newFieldName\n              }\n            };\n          }\n          newFieldConfigMap[newFieldName] = newFieldConfig === undefined ? originalFieldConfig : newFieldConfig;\n        } else if (mappedField !== null) {\n          newFieldConfigMap[fieldName] = mappedField;\n        }\n      }\n      if ((0, graphql_1.isObjectType)(originalType)) {\n        newTypeMap[typeName] = correctASTNodes(new graphql_1.GraphQLObjectType({\n          ...config,\n          fields: newFieldConfigMap\n        }));\n      } else if ((0, graphql_1.isInterfaceType)(originalType)) {\n        newTypeMap[typeName] = correctASTNodes(new graphql_1.GraphQLInterfaceType({\n          ...config,\n          fields: newFieldConfigMap\n        }));\n      } else {\n        newTypeMap[typeName] = correctASTNodes(new graphql_1.GraphQLInputObjectType({\n          ...config,\n          fields: newFieldConfigMap\n        }));\n      }\n    }\n  }\n  return newTypeMap;\n}\nfunction mapArguments(originalTypeMap, schema, schemaMapper) {\n  const newTypeMap = {};\n  for (const typeName in originalTypeMap) {\n    if (!typeName.startsWith('__')) {\n      const originalType = originalTypeMap[typeName];\n      if (!(0, graphql_1.isObjectType)(originalType) && !(0, graphql_1.isInterfaceType)(originalType)) {\n        newTypeMap[typeName] = originalType;\n        continue;\n      }\n      const argumentMapper = getArgumentMapper(schemaMapper);\n      if (argumentMapper == null) {\n        newTypeMap[typeName] = originalType;\n        continue;\n      }\n      const config = originalType.toConfig();\n      const originalFieldConfigMap = config.fields;\n      const newFieldConfigMap = {};\n      for (const fieldName in originalFieldConfigMap) {\n        const originalFieldConfig = originalFieldConfigMap[fieldName];\n        const originalArgumentConfigMap = originalFieldConfig.args;\n        if (originalArgumentConfigMap == null) {\n          newFieldConfigMap[fieldName] = originalFieldConfig;\n          continue;\n        }\n        const argumentNames = Object.keys(originalArgumentConfigMap);\n        if (!argumentNames.length) {\n          newFieldConfigMap[fieldName] = originalFieldConfig;\n          continue;\n        }\n        const newArgumentConfigMap = {};\n        for (const argumentName of argumentNames) {\n          const originalArgumentConfig = originalArgumentConfigMap[argumentName];\n          const mappedArgument = argumentMapper(originalArgumentConfig, fieldName, typeName, schema);\n          if (mappedArgument === undefined) {\n            newArgumentConfigMap[argumentName] = originalArgumentConfig;\n          } else if (Array.isArray(mappedArgument)) {\n            const [newArgumentName, newArgumentConfig] = mappedArgument;\n            newArgumentConfigMap[newArgumentName] = newArgumentConfig;\n          } else if (mappedArgument !== null) {\n            newArgumentConfigMap[argumentName] = mappedArgument;\n          }\n        }\n        newFieldConfigMap[fieldName] = {\n          ...originalFieldConfig,\n          args: newArgumentConfigMap\n        };\n      }\n      if ((0, graphql_1.isObjectType)(originalType)) {\n        newTypeMap[typeName] = new graphql_1.GraphQLObjectType({\n          ...config,\n          fields: newFieldConfigMap\n        });\n      } else if ((0, graphql_1.isInterfaceType)(originalType)) {\n        newTypeMap[typeName] = new graphql_1.GraphQLInterfaceType({\n          ...config,\n          fields: newFieldConfigMap\n        });\n      } else {\n        newTypeMap[typeName] = new graphql_1.GraphQLInputObjectType({\n          ...config,\n          fields: newFieldConfigMap\n        });\n      }\n    }\n  }\n  return newTypeMap;\n}\nfunction mapDirectives(originalDirectives, schema, schemaMapper) {\n  const directiveMapper = getDirectiveMapper(schemaMapper);\n  if (directiveMapper == null) {\n    return originalDirectives.slice();\n  }\n  const newDirectives = [];\n  for (const directive of originalDirectives) {\n    const mappedDirective = directiveMapper(directive, schema);\n    if (mappedDirective === undefined) {\n      newDirectives.push(directive);\n    } else if (mappedDirective !== null) {\n      newDirectives.push(mappedDirective);\n    }\n  }\n  return newDirectives;\n}\nfunction getTypeSpecifiers(schema, typeName) {\n  var _a, _b, _c;\n  const type = schema.getType(typeName);\n  const specifiers = [Interfaces_js_1.MapperKind.TYPE];\n  if ((0, graphql_1.isObjectType)(type)) {\n    specifiers.push(Interfaces_js_1.MapperKind.COMPOSITE_TYPE, Interfaces_js_1.MapperKind.OBJECT_TYPE);\n    if (typeName === ((_a = schema.getQueryType()) === null || _a === void 0 ? void 0 : _a.name)) {\n      specifiers.push(Interfaces_js_1.MapperKind.ROOT_OBJECT, Interfaces_js_1.MapperKind.QUERY);\n    } else if (typeName === ((_b = schema.getMutationType()) === null || _b === void 0 ? void 0 : _b.name)) {\n      specifiers.push(Interfaces_js_1.MapperKind.ROOT_OBJECT, Interfaces_js_1.MapperKind.MUTATION);\n    } else if (typeName === ((_c = schema.getSubscriptionType()) === null || _c === void 0 ? void 0 : _c.name)) {\n      specifiers.push(Interfaces_js_1.MapperKind.ROOT_OBJECT, Interfaces_js_1.MapperKind.SUBSCRIPTION);\n    }\n  } else if ((0, graphql_1.isInputObjectType)(type)) {\n    specifiers.push(Interfaces_js_1.MapperKind.INPUT_OBJECT_TYPE);\n  } else if ((0, graphql_1.isInterfaceType)(type)) {\n    specifiers.push(Interfaces_js_1.MapperKind.COMPOSITE_TYPE, Interfaces_js_1.MapperKind.ABSTRACT_TYPE, Interfaces_js_1.MapperKind.INTERFACE_TYPE);\n  } else if ((0, graphql_1.isUnionType)(type)) {\n    specifiers.push(Interfaces_js_1.MapperKind.COMPOSITE_TYPE, Interfaces_js_1.MapperKind.ABSTRACT_TYPE, Interfaces_js_1.MapperKind.UNION_TYPE);\n  } else if ((0, graphql_1.isEnumType)(type)) {\n    specifiers.push(Interfaces_js_1.MapperKind.ENUM_TYPE);\n  } else if ((0, graphql_1.isScalarType)(type)) {\n    specifiers.push(Interfaces_js_1.MapperKind.SCALAR_TYPE);\n  }\n  return specifiers;\n}\nfunction getTypeMapper(schema, schemaMapper, typeName) {\n  const specifiers = getTypeSpecifiers(schema, typeName);\n  let typeMapper;\n  const stack = [...specifiers];\n  while (!typeMapper && stack.length > 0) {\n    // It is safe to use the ! operator here as we check the length.\n    const next = stack.pop();\n    typeMapper = schemaMapper[next];\n  }\n  return typeMapper != null ? typeMapper : null;\n}\nfunction getFieldSpecifiers(schema, typeName) {\n  var _a, _b, _c;\n  const type = schema.getType(typeName);\n  const specifiers = [Interfaces_js_1.MapperKind.FIELD];\n  if ((0, graphql_1.isObjectType)(type)) {\n    specifiers.push(Interfaces_js_1.MapperKind.COMPOSITE_FIELD, Interfaces_js_1.MapperKind.OBJECT_FIELD);\n    if (typeName === ((_a = schema.getQueryType()) === null || _a === void 0 ? void 0 : _a.name)) {\n      specifiers.push(Interfaces_js_1.MapperKind.ROOT_FIELD, Interfaces_js_1.MapperKind.QUERY_ROOT_FIELD);\n    } else if (typeName === ((_b = schema.getMutationType()) === null || _b === void 0 ? void 0 : _b.name)) {\n      specifiers.push(Interfaces_js_1.MapperKind.ROOT_FIELD, Interfaces_js_1.MapperKind.MUTATION_ROOT_FIELD);\n    } else if (typeName === ((_c = schema.getSubscriptionType()) === null || _c === void 0 ? void 0 : _c.name)) {\n      specifiers.push(Interfaces_js_1.MapperKind.ROOT_FIELD, Interfaces_js_1.MapperKind.SUBSCRIPTION_ROOT_FIELD);\n    }\n  } else if ((0, graphql_1.isInterfaceType)(type)) {\n    specifiers.push(Interfaces_js_1.MapperKind.COMPOSITE_FIELD, Interfaces_js_1.MapperKind.INTERFACE_FIELD);\n  } else if ((0, graphql_1.isInputObjectType)(type)) {\n    specifiers.push(Interfaces_js_1.MapperKind.INPUT_OBJECT_FIELD);\n  }\n  return specifiers;\n}\nfunction getFieldMapper(schema, schemaMapper, typeName) {\n  const specifiers = getFieldSpecifiers(schema, typeName);\n  let fieldMapper;\n  const stack = [...specifiers];\n  while (!fieldMapper && stack.length > 0) {\n    // It is safe to use the ! operator here as we check the length.\n    const next = stack.pop();\n    // TODO: fix this as unknown cast\n    fieldMapper = schemaMapper[next];\n  }\n  return fieldMapper !== null && fieldMapper !== void 0 ? fieldMapper : null;\n}\nfunction getArgumentMapper(schemaMapper) {\n  const argumentMapper = schemaMapper[Interfaces_js_1.MapperKind.ARGUMENT];\n  return argumentMapper != null ? argumentMapper : null;\n}\nfunction getDirectiveMapper(schemaMapper) {\n  const directiveMapper = schemaMapper[Interfaces_js_1.MapperKind.DIRECTIVE];\n  return directiveMapper != null ? directiveMapper : null;\n}\nfunction getEnumValueMapper(schemaMapper) {\n  const enumValueMapper = schemaMapper[Interfaces_js_1.MapperKind.ENUM_VALUE];\n  return enumValueMapper != null ? enumValueMapper : null;\n}\nfunction correctASTNodes(type) {\n  if ((0, graphql_1.isObjectType)(type)) {\n    const config = type.toConfig();\n    if (config.astNode != null) {\n      const fields = [];\n      for (const fieldName in config.fields) {\n        const fieldConfig = config.fields[fieldName];\n        if (fieldConfig.astNode != null) {\n          fields.push(fieldConfig.astNode);\n        }\n      }\n      config.astNode = {\n        ...config.astNode,\n        kind: graphql_1.Kind.OBJECT_TYPE_DEFINITION,\n        fields\n      };\n    }\n    if (config.extensionASTNodes != null) {\n      config.extensionASTNodes = config.extensionASTNodes.map(node => ({\n        ...node,\n        kind: graphql_1.Kind.OBJECT_TYPE_EXTENSION,\n        fields: undefined\n      }));\n    }\n    return new graphql_1.GraphQLObjectType(config);\n  } else if ((0, graphql_1.isInterfaceType)(type)) {\n    const config = type.toConfig();\n    if (config.astNode != null) {\n      const fields = [];\n      for (const fieldName in config.fields) {\n        const fieldConfig = config.fields[fieldName];\n        if (fieldConfig.astNode != null) {\n          fields.push(fieldConfig.astNode);\n        }\n      }\n      config.astNode = {\n        ...config.astNode,\n        kind: graphql_1.Kind.INTERFACE_TYPE_DEFINITION,\n        fields\n      };\n    }\n    if (config.extensionASTNodes != null) {\n      config.extensionASTNodes = config.extensionASTNodes.map(node => ({\n        ...node,\n        kind: graphql_1.Kind.INTERFACE_TYPE_EXTENSION,\n        fields: undefined\n      }));\n    }\n    return new graphql_1.GraphQLInterfaceType(config);\n  } else if ((0, graphql_1.isInputObjectType)(type)) {\n    const config = type.toConfig();\n    if (config.astNode != null) {\n      const fields = [];\n      for (const fieldName in config.fields) {\n        const fieldConfig = config.fields[fieldName];\n        if (fieldConfig.astNode != null) {\n          fields.push(fieldConfig.astNode);\n        }\n      }\n      config.astNode = {\n        ...config.astNode,\n        kind: graphql_1.Kind.INPUT_OBJECT_TYPE_DEFINITION,\n        fields\n      };\n    }\n    if (config.extensionASTNodes != null) {\n      config.extensionASTNodes = config.extensionASTNodes.map(node => ({\n        ...node,\n        kind: graphql_1.Kind.INPUT_OBJECT_TYPE_EXTENSION,\n        fields: undefined\n      }));\n    }\n    return new graphql_1.GraphQLInputObjectType(config);\n  } else if ((0, graphql_1.isEnumType)(type)) {\n    const config = type.toConfig();\n    if (config.astNode != null) {\n      const values = [];\n      for (const enumKey in config.values) {\n        const enumValueConfig = config.values[enumKey];\n        if (enumValueConfig.astNode != null) {\n          values.push(enumValueConfig.astNode);\n        }\n      }\n      config.astNode = {\n        ...config.astNode,\n        values\n      };\n    }\n    if (config.extensionASTNodes != null) {\n      config.extensionASTNodes = config.extensionASTNodes.map(node => ({\n        ...node,\n        values: undefined\n      }));\n    }\n    return new graphql_1.GraphQLEnumType(config);\n  } else {\n    return type;\n  }\n}\nexports.correctASTNodes = correctASTNodes;","map":{"version":3,"names":["Object","defineProperty","exports","value","correctASTNodes","mapSchema","graphql_1","require","getObjectTypeFromTypeMap_js_1","Interfaces_js_1","rewire_js_1","transformInputValue_js_1","schema","schemaMapper","arguments","length","undefined","newTypeMap","mapArguments","mapFields","mapTypes","mapDefaultValues","mapEnumValues","getTypeMap","serializeInputValue","type","isLeafType","parseInputValue","originalDirectives","getDirectives","newDirectives","mapDirectives","typeMap","directives","rewireTypes","GraphQLSchema","toConfig","query","getObjectTypeFromTypeMap","getQueryType","mutation","getMutationType","subscription","getSubscriptionType","types","values","originalTypeMap","testFn","typeName","startsWith","originalType","typeMapper","getTypeMapper","maybeNewType","enumValueMapper","getEnumValueMapper","MapperKind","ENUM_TYPE","config","originalEnumValueConfigMap","newEnumValueConfigMap","externalValue","originalEnumValueConfig","mappedEnumValue","name","Array","isArray","newExternalValue","newEnumValueConfig","GraphQLEnumType","isEnumType","fn","ARGUMENT","argumentConfig","defaultValue","getNewType","INPUT_OBJECT_FIELD","inputFieldConfig","isListType","newType","ofType","GraphQLList","isNonNullType","GraphQLNonNull","isNamedType","isObjectType","isInterfaceType","isInputObjectType","fieldMapper","getFieldMapper","originalFieldConfigMap","fields","newFieldConfigMap","fieldName","originalFieldConfig","mappedField","newFieldName","newFieldConfig","astNode","GraphQLObjectType","GraphQLInterfaceType","GraphQLInputObjectType","argumentMapper","getArgumentMapper","originalArgumentConfigMap","args","argumentNames","keys","newArgumentConfigMap","argumentName","originalArgumentConfig","mappedArgument","newArgumentName","newArgumentConfig","directiveMapper","getDirectiveMapper","slice","directive","mappedDirective","push","getTypeSpecifiers","_a","_b","_c","getType","specifiers","TYPE","COMPOSITE_TYPE","OBJECT_TYPE","ROOT_OBJECT","QUERY","MUTATION","SUBSCRIPTION","INPUT_OBJECT_TYPE","ABSTRACT_TYPE","INTERFACE_TYPE","isUnionType","UNION_TYPE","isScalarType","SCALAR_TYPE","stack","next","pop","getFieldSpecifiers","FIELD","COMPOSITE_FIELD","OBJECT_FIELD","ROOT_FIELD","QUERY_ROOT_FIELD","MUTATION_ROOT_FIELD","SUBSCRIPTION_ROOT_FIELD","INTERFACE_FIELD","DIRECTIVE","ENUM_VALUE","fieldConfig","kind","Kind","OBJECT_TYPE_DEFINITION","extensionASTNodes","map","node","OBJECT_TYPE_EXTENSION","INTERFACE_TYPE_DEFINITION","INTERFACE_TYPE_EXTENSION","INPUT_OBJECT_TYPE_DEFINITION","INPUT_OBJECT_TYPE_EXTENSION","enumKey","enumValueConfig"],"sources":["/Users/chadward/node_modules/@graphql-tools/utils/cjs/mapSchema.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.correctASTNodes = exports.mapSchema = void 0;\nconst graphql_1 = require(\"graphql\");\nconst getObjectTypeFromTypeMap_js_1 = require(\"./getObjectTypeFromTypeMap.js\");\nconst Interfaces_js_1 = require(\"./Interfaces.js\");\nconst rewire_js_1 = require(\"./rewire.js\");\nconst transformInputValue_js_1 = require(\"./transformInputValue.js\");\nfunction mapSchema(schema, schemaMapper = {}) {\n    const newTypeMap = mapArguments(mapFields(mapTypes(mapDefaultValues(mapEnumValues(mapTypes(mapDefaultValues(schema.getTypeMap(), schema, transformInputValue_js_1.serializeInputValue), schema, schemaMapper, type => (0, graphql_1.isLeafType)(type)), schema, schemaMapper), schema, transformInputValue_js_1.parseInputValue), schema, schemaMapper, type => !(0, graphql_1.isLeafType)(type)), schema, schemaMapper), schema, schemaMapper);\n    const originalDirectives = schema.getDirectives();\n    const newDirectives = mapDirectives(originalDirectives, schema, schemaMapper);\n    const { typeMap, directives } = (0, rewire_js_1.rewireTypes)(newTypeMap, newDirectives);\n    return new graphql_1.GraphQLSchema({\n        ...schema.toConfig(),\n        query: (0, getObjectTypeFromTypeMap_js_1.getObjectTypeFromTypeMap)(typeMap, (0, getObjectTypeFromTypeMap_js_1.getObjectTypeFromTypeMap)(newTypeMap, schema.getQueryType())),\n        mutation: (0, getObjectTypeFromTypeMap_js_1.getObjectTypeFromTypeMap)(typeMap, (0, getObjectTypeFromTypeMap_js_1.getObjectTypeFromTypeMap)(newTypeMap, schema.getMutationType())),\n        subscription: (0, getObjectTypeFromTypeMap_js_1.getObjectTypeFromTypeMap)(typeMap, (0, getObjectTypeFromTypeMap_js_1.getObjectTypeFromTypeMap)(newTypeMap, schema.getSubscriptionType())),\n        types: Object.values(typeMap),\n        directives,\n    });\n}\nexports.mapSchema = mapSchema;\nfunction mapTypes(originalTypeMap, schema, schemaMapper, testFn = () => true) {\n    const newTypeMap = {};\n    for (const typeName in originalTypeMap) {\n        if (!typeName.startsWith('__')) {\n            const originalType = originalTypeMap[typeName];\n            if (originalType == null || !testFn(originalType)) {\n                newTypeMap[typeName] = originalType;\n                continue;\n            }\n            const typeMapper = getTypeMapper(schema, schemaMapper, typeName);\n            if (typeMapper == null) {\n                newTypeMap[typeName] = originalType;\n                continue;\n            }\n            const maybeNewType = typeMapper(originalType, schema);\n            if (maybeNewType === undefined) {\n                newTypeMap[typeName] = originalType;\n                continue;\n            }\n            newTypeMap[typeName] = maybeNewType;\n        }\n    }\n    return newTypeMap;\n}\nfunction mapEnumValues(originalTypeMap, schema, schemaMapper) {\n    const enumValueMapper = getEnumValueMapper(schemaMapper);\n    if (!enumValueMapper) {\n        return originalTypeMap;\n    }\n    return mapTypes(originalTypeMap, schema, {\n        [Interfaces_js_1.MapperKind.ENUM_TYPE]: type => {\n            const config = type.toConfig();\n            const originalEnumValueConfigMap = config.values;\n            const newEnumValueConfigMap = {};\n            for (const externalValue in originalEnumValueConfigMap) {\n                const originalEnumValueConfig = originalEnumValueConfigMap[externalValue];\n                const mappedEnumValue = enumValueMapper(originalEnumValueConfig, type.name, schema, externalValue);\n                if (mappedEnumValue === undefined) {\n                    newEnumValueConfigMap[externalValue] = originalEnumValueConfig;\n                }\n                else if (Array.isArray(mappedEnumValue)) {\n                    const [newExternalValue, newEnumValueConfig] = mappedEnumValue;\n                    newEnumValueConfigMap[newExternalValue] =\n                        newEnumValueConfig === undefined ? originalEnumValueConfig : newEnumValueConfig;\n                }\n                else if (mappedEnumValue !== null) {\n                    newEnumValueConfigMap[externalValue] = mappedEnumValue;\n                }\n            }\n            return correctASTNodes(new graphql_1.GraphQLEnumType({\n                ...config,\n                values: newEnumValueConfigMap,\n            }));\n        },\n    }, type => (0, graphql_1.isEnumType)(type));\n}\nfunction mapDefaultValues(originalTypeMap, schema, fn) {\n    const newTypeMap = mapArguments(originalTypeMap, schema, {\n        [Interfaces_js_1.MapperKind.ARGUMENT]: argumentConfig => {\n            if (argumentConfig.defaultValue === undefined) {\n                return argumentConfig;\n            }\n            const maybeNewType = getNewType(originalTypeMap, argumentConfig.type);\n            if (maybeNewType != null) {\n                return {\n                    ...argumentConfig,\n                    defaultValue: fn(maybeNewType, argumentConfig.defaultValue),\n                };\n            }\n        },\n    });\n    return mapFields(newTypeMap, schema, {\n        [Interfaces_js_1.MapperKind.INPUT_OBJECT_FIELD]: inputFieldConfig => {\n            if (inputFieldConfig.defaultValue === undefined) {\n                return inputFieldConfig;\n            }\n            const maybeNewType = getNewType(newTypeMap, inputFieldConfig.type);\n            if (maybeNewType != null) {\n                return {\n                    ...inputFieldConfig,\n                    defaultValue: fn(maybeNewType, inputFieldConfig.defaultValue),\n                };\n            }\n        },\n    });\n}\nfunction getNewType(newTypeMap, type) {\n    if ((0, graphql_1.isListType)(type)) {\n        const newType = getNewType(newTypeMap, type.ofType);\n        return newType != null ? new graphql_1.GraphQLList(newType) : null;\n    }\n    else if ((0, graphql_1.isNonNullType)(type)) {\n        const newType = getNewType(newTypeMap, type.ofType);\n        return newType != null ? new graphql_1.GraphQLNonNull(newType) : null;\n    }\n    else if ((0, graphql_1.isNamedType)(type)) {\n        const newType = newTypeMap[type.name];\n        return newType != null ? newType : null;\n    }\n    return null;\n}\nfunction mapFields(originalTypeMap, schema, schemaMapper) {\n    const newTypeMap = {};\n    for (const typeName in originalTypeMap) {\n        if (!typeName.startsWith('__')) {\n            const originalType = originalTypeMap[typeName];\n            if (!(0, graphql_1.isObjectType)(originalType) && !(0, graphql_1.isInterfaceType)(originalType) && !(0, graphql_1.isInputObjectType)(originalType)) {\n                newTypeMap[typeName] = originalType;\n                continue;\n            }\n            const fieldMapper = getFieldMapper(schema, schemaMapper, typeName);\n            if (fieldMapper == null) {\n                newTypeMap[typeName] = originalType;\n                continue;\n            }\n            const config = originalType.toConfig();\n            const originalFieldConfigMap = config.fields;\n            const newFieldConfigMap = {};\n            for (const fieldName in originalFieldConfigMap) {\n                const originalFieldConfig = originalFieldConfigMap[fieldName];\n                const mappedField = fieldMapper(originalFieldConfig, fieldName, typeName, schema);\n                if (mappedField === undefined) {\n                    newFieldConfigMap[fieldName] = originalFieldConfig;\n                }\n                else if (Array.isArray(mappedField)) {\n                    const [newFieldName, newFieldConfig] = mappedField;\n                    if (newFieldConfig.astNode != null) {\n                        newFieldConfig.astNode = {\n                            ...newFieldConfig.astNode,\n                            name: {\n                                ...newFieldConfig.astNode.name,\n                                value: newFieldName,\n                            },\n                        };\n                    }\n                    newFieldConfigMap[newFieldName] = newFieldConfig === undefined ? originalFieldConfig : newFieldConfig;\n                }\n                else if (mappedField !== null) {\n                    newFieldConfigMap[fieldName] = mappedField;\n                }\n            }\n            if ((0, graphql_1.isObjectType)(originalType)) {\n                newTypeMap[typeName] = correctASTNodes(new graphql_1.GraphQLObjectType({\n                    ...config,\n                    fields: newFieldConfigMap,\n                }));\n            }\n            else if ((0, graphql_1.isInterfaceType)(originalType)) {\n                newTypeMap[typeName] = correctASTNodes(new graphql_1.GraphQLInterfaceType({\n                    ...config,\n                    fields: newFieldConfigMap,\n                }));\n            }\n            else {\n                newTypeMap[typeName] = correctASTNodes(new graphql_1.GraphQLInputObjectType({\n                    ...config,\n                    fields: newFieldConfigMap,\n                }));\n            }\n        }\n    }\n    return newTypeMap;\n}\nfunction mapArguments(originalTypeMap, schema, schemaMapper) {\n    const newTypeMap = {};\n    for (const typeName in originalTypeMap) {\n        if (!typeName.startsWith('__')) {\n            const originalType = originalTypeMap[typeName];\n            if (!(0, graphql_1.isObjectType)(originalType) && !(0, graphql_1.isInterfaceType)(originalType)) {\n                newTypeMap[typeName] = originalType;\n                continue;\n            }\n            const argumentMapper = getArgumentMapper(schemaMapper);\n            if (argumentMapper == null) {\n                newTypeMap[typeName] = originalType;\n                continue;\n            }\n            const config = originalType.toConfig();\n            const originalFieldConfigMap = config.fields;\n            const newFieldConfigMap = {};\n            for (const fieldName in originalFieldConfigMap) {\n                const originalFieldConfig = originalFieldConfigMap[fieldName];\n                const originalArgumentConfigMap = originalFieldConfig.args;\n                if (originalArgumentConfigMap == null) {\n                    newFieldConfigMap[fieldName] = originalFieldConfig;\n                    continue;\n                }\n                const argumentNames = Object.keys(originalArgumentConfigMap);\n                if (!argumentNames.length) {\n                    newFieldConfigMap[fieldName] = originalFieldConfig;\n                    continue;\n                }\n                const newArgumentConfigMap = {};\n                for (const argumentName of argumentNames) {\n                    const originalArgumentConfig = originalArgumentConfigMap[argumentName];\n                    const mappedArgument = argumentMapper(originalArgumentConfig, fieldName, typeName, schema);\n                    if (mappedArgument === undefined) {\n                        newArgumentConfigMap[argumentName] = originalArgumentConfig;\n                    }\n                    else if (Array.isArray(mappedArgument)) {\n                        const [newArgumentName, newArgumentConfig] = mappedArgument;\n                        newArgumentConfigMap[newArgumentName] = newArgumentConfig;\n                    }\n                    else if (mappedArgument !== null) {\n                        newArgumentConfigMap[argumentName] = mappedArgument;\n                    }\n                }\n                newFieldConfigMap[fieldName] = {\n                    ...originalFieldConfig,\n                    args: newArgumentConfigMap,\n                };\n            }\n            if ((0, graphql_1.isObjectType)(originalType)) {\n                newTypeMap[typeName] = new graphql_1.GraphQLObjectType({\n                    ...config,\n                    fields: newFieldConfigMap,\n                });\n            }\n            else if ((0, graphql_1.isInterfaceType)(originalType)) {\n                newTypeMap[typeName] = new graphql_1.GraphQLInterfaceType({\n                    ...config,\n                    fields: newFieldConfigMap,\n                });\n            }\n            else {\n                newTypeMap[typeName] = new graphql_1.GraphQLInputObjectType({\n                    ...config,\n                    fields: newFieldConfigMap,\n                });\n            }\n        }\n    }\n    return newTypeMap;\n}\nfunction mapDirectives(originalDirectives, schema, schemaMapper) {\n    const directiveMapper = getDirectiveMapper(schemaMapper);\n    if (directiveMapper == null) {\n        return originalDirectives.slice();\n    }\n    const newDirectives = [];\n    for (const directive of originalDirectives) {\n        const mappedDirective = directiveMapper(directive, schema);\n        if (mappedDirective === undefined) {\n            newDirectives.push(directive);\n        }\n        else if (mappedDirective !== null) {\n            newDirectives.push(mappedDirective);\n        }\n    }\n    return newDirectives;\n}\nfunction getTypeSpecifiers(schema, typeName) {\n    var _a, _b, _c;\n    const type = schema.getType(typeName);\n    const specifiers = [Interfaces_js_1.MapperKind.TYPE];\n    if ((0, graphql_1.isObjectType)(type)) {\n        specifiers.push(Interfaces_js_1.MapperKind.COMPOSITE_TYPE, Interfaces_js_1.MapperKind.OBJECT_TYPE);\n        if (typeName === ((_a = schema.getQueryType()) === null || _a === void 0 ? void 0 : _a.name)) {\n            specifiers.push(Interfaces_js_1.MapperKind.ROOT_OBJECT, Interfaces_js_1.MapperKind.QUERY);\n        }\n        else if (typeName === ((_b = schema.getMutationType()) === null || _b === void 0 ? void 0 : _b.name)) {\n            specifiers.push(Interfaces_js_1.MapperKind.ROOT_OBJECT, Interfaces_js_1.MapperKind.MUTATION);\n        }\n        else if (typeName === ((_c = schema.getSubscriptionType()) === null || _c === void 0 ? void 0 : _c.name)) {\n            specifiers.push(Interfaces_js_1.MapperKind.ROOT_OBJECT, Interfaces_js_1.MapperKind.SUBSCRIPTION);\n        }\n    }\n    else if ((0, graphql_1.isInputObjectType)(type)) {\n        specifiers.push(Interfaces_js_1.MapperKind.INPUT_OBJECT_TYPE);\n    }\n    else if ((0, graphql_1.isInterfaceType)(type)) {\n        specifiers.push(Interfaces_js_1.MapperKind.COMPOSITE_TYPE, Interfaces_js_1.MapperKind.ABSTRACT_TYPE, Interfaces_js_1.MapperKind.INTERFACE_TYPE);\n    }\n    else if ((0, graphql_1.isUnionType)(type)) {\n        specifiers.push(Interfaces_js_1.MapperKind.COMPOSITE_TYPE, Interfaces_js_1.MapperKind.ABSTRACT_TYPE, Interfaces_js_1.MapperKind.UNION_TYPE);\n    }\n    else if ((0, graphql_1.isEnumType)(type)) {\n        specifiers.push(Interfaces_js_1.MapperKind.ENUM_TYPE);\n    }\n    else if ((0, graphql_1.isScalarType)(type)) {\n        specifiers.push(Interfaces_js_1.MapperKind.SCALAR_TYPE);\n    }\n    return specifiers;\n}\nfunction getTypeMapper(schema, schemaMapper, typeName) {\n    const specifiers = getTypeSpecifiers(schema, typeName);\n    let typeMapper;\n    const stack = [...specifiers];\n    while (!typeMapper && stack.length > 0) {\n        // It is safe to use the ! operator here as we check the length.\n        const next = stack.pop();\n        typeMapper = schemaMapper[next];\n    }\n    return typeMapper != null ? typeMapper : null;\n}\nfunction getFieldSpecifiers(schema, typeName) {\n    var _a, _b, _c;\n    const type = schema.getType(typeName);\n    const specifiers = [Interfaces_js_1.MapperKind.FIELD];\n    if ((0, graphql_1.isObjectType)(type)) {\n        specifiers.push(Interfaces_js_1.MapperKind.COMPOSITE_FIELD, Interfaces_js_1.MapperKind.OBJECT_FIELD);\n        if (typeName === ((_a = schema.getQueryType()) === null || _a === void 0 ? void 0 : _a.name)) {\n            specifiers.push(Interfaces_js_1.MapperKind.ROOT_FIELD, Interfaces_js_1.MapperKind.QUERY_ROOT_FIELD);\n        }\n        else if (typeName === ((_b = schema.getMutationType()) === null || _b === void 0 ? void 0 : _b.name)) {\n            specifiers.push(Interfaces_js_1.MapperKind.ROOT_FIELD, Interfaces_js_1.MapperKind.MUTATION_ROOT_FIELD);\n        }\n        else if (typeName === ((_c = schema.getSubscriptionType()) === null || _c === void 0 ? void 0 : _c.name)) {\n            specifiers.push(Interfaces_js_1.MapperKind.ROOT_FIELD, Interfaces_js_1.MapperKind.SUBSCRIPTION_ROOT_FIELD);\n        }\n    }\n    else if ((0, graphql_1.isInterfaceType)(type)) {\n        specifiers.push(Interfaces_js_1.MapperKind.COMPOSITE_FIELD, Interfaces_js_1.MapperKind.INTERFACE_FIELD);\n    }\n    else if ((0, graphql_1.isInputObjectType)(type)) {\n        specifiers.push(Interfaces_js_1.MapperKind.INPUT_OBJECT_FIELD);\n    }\n    return specifiers;\n}\nfunction getFieldMapper(schema, schemaMapper, typeName) {\n    const specifiers = getFieldSpecifiers(schema, typeName);\n    let fieldMapper;\n    const stack = [...specifiers];\n    while (!fieldMapper && stack.length > 0) {\n        // It is safe to use the ! operator here as we check the length.\n        const next = stack.pop();\n        // TODO: fix this as unknown cast\n        fieldMapper = schemaMapper[next];\n    }\n    return fieldMapper !== null && fieldMapper !== void 0 ? fieldMapper : null;\n}\nfunction getArgumentMapper(schemaMapper) {\n    const argumentMapper = schemaMapper[Interfaces_js_1.MapperKind.ARGUMENT];\n    return argumentMapper != null ? argumentMapper : null;\n}\nfunction getDirectiveMapper(schemaMapper) {\n    const directiveMapper = schemaMapper[Interfaces_js_1.MapperKind.DIRECTIVE];\n    return directiveMapper != null ? directiveMapper : null;\n}\nfunction getEnumValueMapper(schemaMapper) {\n    const enumValueMapper = schemaMapper[Interfaces_js_1.MapperKind.ENUM_VALUE];\n    return enumValueMapper != null ? enumValueMapper : null;\n}\nfunction correctASTNodes(type) {\n    if ((0, graphql_1.isObjectType)(type)) {\n        const config = type.toConfig();\n        if (config.astNode != null) {\n            const fields = [];\n            for (const fieldName in config.fields) {\n                const fieldConfig = config.fields[fieldName];\n                if (fieldConfig.astNode != null) {\n                    fields.push(fieldConfig.astNode);\n                }\n            }\n            config.astNode = {\n                ...config.astNode,\n                kind: graphql_1.Kind.OBJECT_TYPE_DEFINITION,\n                fields,\n            };\n        }\n        if (config.extensionASTNodes != null) {\n            config.extensionASTNodes = config.extensionASTNodes.map(node => ({\n                ...node,\n                kind: graphql_1.Kind.OBJECT_TYPE_EXTENSION,\n                fields: undefined,\n            }));\n        }\n        return new graphql_1.GraphQLObjectType(config);\n    }\n    else if ((0, graphql_1.isInterfaceType)(type)) {\n        const config = type.toConfig();\n        if (config.astNode != null) {\n            const fields = [];\n            for (const fieldName in config.fields) {\n                const fieldConfig = config.fields[fieldName];\n                if (fieldConfig.astNode != null) {\n                    fields.push(fieldConfig.astNode);\n                }\n            }\n            config.astNode = {\n                ...config.astNode,\n                kind: graphql_1.Kind.INTERFACE_TYPE_DEFINITION,\n                fields,\n            };\n        }\n        if (config.extensionASTNodes != null) {\n            config.extensionASTNodes = config.extensionASTNodes.map(node => ({\n                ...node,\n                kind: graphql_1.Kind.INTERFACE_TYPE_EXTENSION,\n                fields: undefined,\n            }));\n        }\n        return new graphql_1.GraphQLInterfaceType(config);\n    }\n    else if ((0, graphql_1.isInputObjectType)(type)) {\n        const config = type.toConfig();\n        if (config.astNode != null) {\n            const fields = [];\n            for (const fieldName in config.fields) {\n                const fieldConfig = config.fields[fieldName];\n                if (fieldConfig.astNode != null) {\n                    fields.push(fieldConfig.astNode);\n                }\n            }\n            config.astNode = {\n                ...config.astNode,\n                kind: graphql_1.Kind.INPUT_OBJECT_TYPE_DEFINITION,\n                fields,\n            };\n        }\n        if (config.extensionASTNodes != null) {\n            config.extensionASTNodes = config.extensionASTNodes.map(node => ({\n                ...node,\n                kind: graphql_1.Kind.INPUT_OBJECT_TYPE_EXTENSION,\n                fields: undefined,\n            }));\n        }\n        return new graphql_1.GraphQLInputObjectType(config);\n    }\n    else if ((0, graphql_1.isEnumType)(type)) {\n        const config = type.toConfig();\n        if (config.astNode != null) {\n            const values = [];\n            for (const enumKey in config.values) {\n                const enumValueConfig = config.values[enumKey];\n                if (enumValueConfig.astNode != null) {\n                    values.push(enumValueConfig.astNode);\n                }\n            }\n            config.astNode = {\n                ...config.astNode,\n                values,\n            };\n        }\n        if (config.extensionASTNodes != null) {\n            config.extensionASTNodes = config.extensionASTNodes.map(node => ({\n                ...node,\n                values: undefined,\n            }));\n        }\n        return new graphql_1.GraphQLEnumType(config);\n    }\n    else {\n        return type;\n    }\n}\nexports.correctASTNodes = correctASTNodes;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}