{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Dispatcher = void 0;\nclass Dispatcher {\n  constructor(targets) {\n    this.targets = targets;\n  }\n  callTargets(methodName) {\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n    return this.targets.map(target => {\n      const method = target[methodName];\n      if (typeof method === 'function') {\n        return method.apply(target, args);\n      }\n    });\n  }\n  hasHook(methodName) {\n    return this.targets.some(target => typeof target[methodName] === 'function');\n  }\n  async invokeHook(methodName) {\n    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      args[_key2 - 1] = arguments[_key2];\n    }\n    return Promise.all(this.callTargets(methodName, ...args));\n  }\n  async invokeHooksUntilNonNull(methodName) {\n    for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n      args[_key3 - 1] = arguments[_key3];\n    }\n    for (const target of this.targets) {\n      const method = target[methodName];\n      if (typeof method !== 'function') {\n        continue;\n      }\n      const value = await method.apply(target, args);\n      if (value !== null) {\n        return value;\n      }\n    }\n    return null;\n  }\n  async invokeDidStartHook(methodName) {\n    for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n      args[_key4 - 1] = arguments[_key4];\n    }\n    const hookReturnValues = await Promise.all(this.callTargets(methodName, ...args));\n    const didEndHooks = hookReturnValues.filter(hook => !!hook);\n    didEndHooks.reverse();\n    return async function () {\n      for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n        args[_key5] = arguments[_key5];\n      }\n      await Promise.all(didEndHooks.map(hook => hook(...args)));\n    };\n  }\n  invokeSyncDidStartHook(methodName) {\n    const didEndHooks = [];\n    for (var _len6 = arguments.length, args = new Array(_len6 > 1 ? _len6 - 1 : 0), _key6 = 1; _key6 < _len6; _key6++) {\n      args[_key6 - 1] = arguments[_key6];\n    }\n    for (const target of this.targets) {\n      const method = target[methodName];\n      if (typeof method === 'function') {\n        const didEndHook = method.apply(target, args);\n        if (didEndHook) {\n          didEndHooks.push(didEndHook);\n        }\n      }\n    }\n    didEndHooks.reverse();\n    return function () {\n      for (const didEndHook of didEndHooks) {\n        didEndHook(...arguments);\n      }\n    };\n  }\n}\nexports.Dispatcher = Dispatcher;","map":{"version":3,"names":["Dispatcher","constructor","targets","callTargets","methodName","_len","arguments","length","args","Array","_key","map","target","method","apply","hasHook","some","invokeHook","_len2","_key2","Promise","all","invokeHooksUntilNonNull","_len3","_key3","value","invokeDidStartHook","_len4","_key4","hookReturnValues","didEndHooks","filter","hook","reverse","_len5","_key5","invokeSyncDidStartHook","_len6","_key6","didEndHook","push","exports"],"sources":["/Users/chadward/node_modules/apollo-server-core/src/utils/dispatcher.ts"],"sourcesContent":["import type { AnyFunction, AnyFunctionMap } from 'apollo-server-types';\n\ntype Args<F> = F extends (...args: infer A) => any ? A : never;\ntype AsFunction<F> = F extends AnyFunction ? F : never;\ntype StripPromise<T> = T extends Promise<infer U> ? U : never;\n\ntype DidEndHook<TArgs extends any[]> = (...args: TArgs) => void;\ntype AsyncDidEndHook<TArgs extends any[]> = (...args: TArgs) => Promise<void>;\n\nexport class Dispatcher<T extends AnyFunctionMap> {\n  constructor(protected targets: T[]) {}\n\n  private callTargets<TMethodName extends keyof T>(\n    methodName: TMethodName,\n    ...args: Args<T[TMethodName]>\n  ): ReturnType<AsFunction<T[TMethodName]>>[] {\n    return this.targets.map((target) => {\n      const method = target[methodName];\n      if (typeof method === 'function') {\n        return method.apply(target, args);\n      }\n    });\n  }\n\n  public hasHook(methodName: keyof T): boolean {\n    return this.targets.some(\n      (target) => typeof target[methodName] === 'function',\n    );\n  }\n\n  public async invokeHook<\n    TMethodName extends keyof T,\n    THookReturn extends StripPromise<ReturnType<AsFunction<T[TMethodName]>>>,\n  >(\n    methodName: TMethodName,\n    ...args: Args<T[TMethodName]>\n  ): Promise<THookReturn[]> {\n    return Promise.all(this.callTargets(methodName, ...args));\n  }\n\n  public async invokeHooksUntilNonNull<TMethodName extends keyof T>(\n    methodName: TMethodName,\n    ...args: Args<T[TMethodName]>\n  ): Promise<StripPromise<ReturnType<AsFunction<T[TMethodName]>>> | null> {\n    for (const target of this.targets) {\n      const method = target[methodName];\n      if (typeof method !== 'function') {\n        continue;\n      }\n      const value = await method.apply(target, args);\n      if (value !== null) {\n        return value;\n      }\n    }\n    return null;\n  }\n\n  public async invokeDidStartHook<\n    TMethodName extends keyof T,\n    TEndHookArgs extends Args<\n      StripPromise<ReturnType<AsFunction<T[TMethodName]>>>\n    >,\n  >(\n    methodName: TMethodName,\n    ...args: Args<T[TMethodName]>\n  ): Promise<AsyncDidEndHook<TEndHookArgs>> {\n    const hookReturnValues: (AsyncDidEndHook<TEndHookArgs> | void)[] =\n      await Promise.all(this.callTargets(methodName, ...args));\n\n    const didEndHooks = hookReturnValues.filter(\n      (hook): hook is AsyncDidEndHook<TEndHookArgs> => !!hook,\n    );\n    didEndHooks.reverse();\n\n    return async (...args: TEndHookArgs) => {\n      await Promise.all(didEndHooks.map((hook) => hook(...args)));\n    };\n  }\n\n  // Almost all hooks are async, but as a special case, willResolveField is sync\n  // due to performance concerns.\n  public invokeSyncDidStartHook<\n    TMethodName extends keyof T,\n    TEndHookArgs extends Args<ReturnType<AsFunction<T[TMethodName]>>>,\n  >(\n    methodName: TMethodName,\n    ...args: Args<T[TMethodName]>\n  ): DidEndHook<TEndHookArgs> {\n    const didEndHooks: DidEndHook<TEndHookArgs>[] = [];\n\n    for (const target of this.targets) {\n      const method = target[methodName];\n      if (typeof method === 'function') {\n        const didEndHook = method.apply(target, args);\n        if (didEndHook) {\n          didEndHooks.push(didEndHook);\n        }\n      }\n    }\n    didEndHooks.reverse();\n\n    return (...args: TEndHookArgs) => {\n      for (const didEndHook of didEndHooks) {\n        didEndHook(...args);\n      }\n    };\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}