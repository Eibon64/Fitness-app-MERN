{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.assertResolversPresent = void 0;\nconst graphql_1 = require(\"graphql\");\nconst utils_1 = require(\"@graphql-tools/utils\");\nfunction assertResolversPresent(schema) {\n  let resolverValidationOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const {\n    requireResolversForArgs,\n    requireResolversForNonScalar,\n    requireResolversForAllFields\n  } = resolverValidationOptions;\n  if (requireResolversForAllFields && (requireResolversForArgs || requireResolversForNonScalar)) {\n    throw new TypeError('requireResolversForAllFields takes precedence over the more specific assertions. ' + 'Please configure either requireResolversForAllFields or requireResolversForArgs / ' + 'requireResolversForNonScalar, but not a combination of them.');\n  }\n  (0, utils_1.forEachField)(schema, (field, typeName, fieldName) => {\n    // requires a resolver for *every* field.\n    if (requireResolversForAllFields) {\n      expectResolver('requireResolversForAllFields', requireResolversForAllFields, field, typeName, fieldName);\n    }\n    // requires a resolver on every field that has arguments\n    if (requireResolversForArgs && field.args.length > 0) {\n      expectResolver('requireResolversForArgs', requireResolversForArgs, field, typeName, fieldName);\n    }\n    // requires a resolver on every field that returns a non-scalar type\n    if (requireResolversForNonScalar !== 'ignore' && !(0, graphql_1.isScalarType)((0, graphql_1.getNamedType)(field.type))) {\n      expectResolver('requireResolversForNonScalar', requireResolversForNonScalar, field, typeName, fieldName);\n    }\n  });\n}\nexports.assertResolversPresent = assertResolversPresent;\nfunction expectResolver(validator, behavior, field, typeName, fieldName) {\n  if (!field.resolve) {\n    const message = `Resolver missing for \"${typeName}.${fieldName}\".\nTo disable this validator, use:\n  resolverValidationOptions: {\n    ${validator}: 'ignore'\n  }`;\n    if (behavior === 'error') {\n      throw new Error(message);\n    }\n    if (behavior === 'warn') {\n      console.warn(message);\n    }\n    return;\n  }\n  if (typeof field.resolve !== 'function') {\n    throw new Error(`Resolver \"${typeName}.${fieldName}\" must be a function`);\n  }\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","assertResolversPresent","graphql_1","require","utils_1","schema","resolverValidationOptions","arguments","length","undefined","requireResolversForArgs","requireResolversForNonScalar","requireResolversForAllFields","TypeError","forEachField","field","typeName","fieldName","expectResolver","args","isScalarType","getNamedType","type","validator","behavior","resolve","message","Error","console","warn"],"sources":["/Users/chadward/node_modules/@graphql-tools/mock/node_modules/@graphql-tools/schema/cjs/assertResolversPresent.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.assertResolversPresent = void 0;\nconst graphql_1 = require(\"graphql\");\nconst utils_1 = require(\"@graphql-tools/utils\");\nfunction assertResolversPresent(schema, resolverValidationOptions = {}) {\n    const { requireResolversForArgs, requireResolversForNonScalar, requireResolversForAllFields } = resolverValidationOptions;\n    if (requireResolversForAllFields && (requireResolversForArgs || requireResolversForNonScalar)) {\n        throw new TypeError('requireResolversForAllFields takes precedence over the more specific assertions. ' +\n            'Please configure either requireResolversForAllFields or requireResolversForArgs / ' +\n            'requireResolversForNonScalar, but not a combination of them.');\n    }\n    (0, utils_1.forEachField)(schema, (field, typeName, fieldName) => {\n        // requires a resolver for *every* field.\n        if (requireResolversForAllFields) {\n            expectResolver('requireResolversForAllFields', requireResolversForAllFields, field, typeName, fieldName);\n        }\n        // requires a resolver on every field that has arguments\n        if (requireResolversForArgs && field.args.length > 0) {\n            expectResolver('requireResolversForArgs', requireResolversForArgs, field, typeName, fieldName);\n        }\n        // requires a resolver on every field that returns a non-scalar type\n        if (requireResolversForNonScalar !== 'ignore' && !(0, graphql_1.isScalarType)((0, graphql_1.getNamedType)(field.type))) {\n            expectResolver('requireResolversForNonScalar', requireResolversForNonScalar, field, typeName, fieldName);\n        }\n    });\n}\nexports.assertResolversPresent = assertResolversPresent;\nfunction expectResolver(validator, behavior, field, typeName, fieldName) {\n    if (!field.resolve) {\n        const message = `Resolver missing for \"${typeName}.${fieldName}\".\nTo disable this validator, use:\n  resolverValidationOptions: {\n    ${validator}: 'ignore'\n  }`;\n        if (behavior === 'error') {\n            throw new Error(message);\n        }\n        if (behavior === 'warn') {\n            console.warn(message);\n        }\n        return;\n    }\n    if (typeof field.resolve !== 'function') {\n        throw new Error(`Resolver \"${typeName}.${fieldName}\" must be a function`);\n    }\n}\n"],"mappings":"AAAA,YAAY;;AACZA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7DD,OAAO,CAACE,sBAAsB,GAAG,KAAK,CAAC;AACvC,MAAMC,SAAS,GAAGC,OAAO,CAAC,SAAS,CAAC;AACpC,MAAMC,OAAO,GAAGD,OAAO,CAAC,sBAAsB,CAAC;AAC/C,SAASF,sBAAsBA,CAACI,MAAM,EAAkC;EAAA,IAAhCC,yBAAyB,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,CAAC,CAAC;EAClE,MAAM;IAAEG,uBAAuB;IAAEC,4BAA4B;IAAEC;EAA6B,CAAC,GAAGN,yBAAyB;EACzH,IAAIM,4BAA4B,KAAKF,uBAAuB,IAAIC,4BAA4B,CAAC,EAAE;IAC3F,MAAM,IAAIE,SAAS,CAAC,mFAAmF,GACnG,oFAAoF,GACpF,8DAA8D,CAAC;EACvE;EACA,CAAC,CAAC,EAAET,OAAO,CAACU,YAAY,EAAET,MAAM,EAAE,CAACU,KAAK,EAAEC,QAAQ,EAAEC,SAAS,KAAK;IAC9D;IACA,IAAIL,4BAA4B,EAAE;MAC9BM,cAAc,CAAC,8BAA8B,EAAEN,4BAA4B,EAAEG,KAAK,EAAEC,QAAQ,EAAEC,SAAS,CAAC;IAC5G;IACA;IACA,IAAIP,uBAAuB,IAAIK,KAAK,CAACI,IAAI,CAACX,MAAM,GAAG,CAAC,EAAE;MAClDU,cAAc,CAAC,yBAAyB,EAAER,uBAAuB,EAAEK,KAAK,EAAEC,QAAQ,EAAEC,SAAS,CAAC;IAClG;IACA;IACA,IAAIN,4BAA4B,KAAK,QAAQ,IAAI,CAAC,CAAC,CAAC,EAAET,SAAS,CAACkB,YAAY,EAAE,CAAC,CAAC,EAAElB,SAAS,CAACmB,YAAY,EAAEN,KAAK,CAACO,IAAI,CAAC,CAAC,EAAE;MACpHJ,cAAc,CAAC,8BAA8B,EAAEP,4BAA4B,EAAEI,KAAK,EAAEC,QAAQ,EAAEC,SAAS,CAAC;IAC5G;EACJ,CAAC,CAAC;AACN;AACAlB,OAAO,CAACE,sBAAsB,GAAGA,sBAAsB;AACvD,SAASiB,cAAcA,CAACK,SAAS,EAAEC,QAAQ,EAAET,KAAK,EAAEC,QAAQ,EAAEC,SAAS,EAAE;EACrE,IAAI,CAACF,KAAK,CAACU,OAAO,EAAE;IAChB,MAAMC,OAAO,GAAI,yBAAwBV,QAAS,IAAGC,SAAU;AACvE;AACA;AACA,MAAMM,SAAU;AAChB,IAAI;IACI,IAAIC,QAAQ,KAAK,OAAO,EAAE;MACtB,MAAM,IAAIG,KAAK,CAACD,OAAO,CAAC;IAC5B;IACA,IAAIF,QAAQ,KAAK,MAAM,EAAE;MACrBI,OAAO,CAACC,IAAI,CAACH,OAAO,CAAC;IACzB;IACA;EACJ;EACA,IAAI,OAAOX,KAAK,CAACU,OAAO,KAAK,UAAU,EAAE;IACrC,MAAM,IAAIE,KAAK,CAAE,aAAYX,QAAS,IAAGC,SAAU,sBAAqB,CAAC;EAC7E;AACJ"},"metadata":{},"sourceType":"script","externalDependencies":[]}