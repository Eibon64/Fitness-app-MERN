{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.mergeGraphQLTypes = exports.mergeTypeDefs = void 0;\nconst graphql_1 = require(\"graphql\");\nconst utils_js_1 = require(\"./utils.js\");\nconst merge_nodes_js_1 = require(\"./merge-nodes.js\");\nconst utils_1 = require(\"@graphql-tools/utils\");\nconst schema_def_js_1 = require(\"./schema-def.js\");\nfunction mergeTypeDefs(typeSource, config) {\n  (0, utils_1.resetComments)();\n  const doc = {\n    kind: graphql_1.Kind.DOCUMENT,\n    definitions: mergeGraphQLTypes(typeSource, {\n      useSchemaDefinition: true,\n      forceSchemaDefinition: false,\n      throwOnConflict: false,\n      commentDescriptions: false,\n      ...config\n    })\n  };\n  let result;\n  if (config === null || config === void 0 ? void 0 : config.commentDescriptions) {\n    result = (0, utils_1.printWithComments)(doc);\n  } else {\n    result = doc;\n  }\n  (0, utils_1.resetComments)();\n  return result;\n}\nexports.mergeTypeDefs = mergeTypeDefs;\nfunction visitTypeSources(typeSource, options) {\n  let allNodes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  let visitedTypeSources = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new Set();\n  if (typeSource && !visitedTypeSources.has(typeSource)) {\n    visitedTypeSources.add(typeSource);\n    if (typeof typeSource === 'function') {\n      visitTypeSources(typeSource(), options, allNodes, visitedTypeSources);\n    } else if (Array.isArray(typeSource)) {\n      for (const type of typeSource) {\n        visitTypeSources(type, options, allNodes, visitedTypeSources);\n      }\n    } else if ((0, graphql_1.isSchema)(typeSource)) {\n      const documentNode = (0, utils_1.getDocumentNodeFromSchema)(typeSource, options);\n      visitTypeSources(documentNode.definitions, options, allNodes, visitedTypeSources);\n    } else if ((0, utils_js_1.isStringTypes)(typeSource) || (0, utils_js_1.isSourceTypes)(typeSource)) {\n      const documentNode = (0, graphql_1.parse)(typeSource, options);\n      visitTypeSources(documentNode.definitions, options, allNodes, visitedTypeSources);\n    } else if (typeof typeSource === 'object' && (0, graphql_1.isDefinitionNode)(typeSource)) {\n      allNodes.push(typeSource);\n    } else if ((0, utils_1.isDocumentNode)(typeSource)) {\n      visitTypeSources(typeSource.definitions, options, allNodes, visitedTypeSources);\n    } else {\n      throw new Error(`typeDefs must contain only strings, documents, schemas, or functions, got ${typeof typeSource}`);\n    }\n  }\n  return allNodes;\n}\nfunction mergeGraphQLTypes(typeSource, config) {\n  var _a, _b, _c;\n  (0, utils_1.resetComments)();\n  const allNodes = visitTypeSources(typeSource, config);\n  const mergedNodes = (0, merge_nodes_js_1.mergeGraphQLNodes)(allNodes, config);\n  if (config === null || config === void 0 ? void 0 : config.useSchemaDefinition) {\n    // XXX: right now we don't handle multiple schema definitions\n    const schemaDef = mergedNodes[merge_nodes_js_1.schemaDefSymbol] || {\n      kind: graphql_1.Kind.SCHEMA_DEFINITION,\n      operationTypes: []\n    };\n    const operationTypes = schemaDef.operationTypes;\n    for (const opTypeDefNodeType in schema_def_js_1.DEFAULT_OPERATION_TYPE_NAME_MAP) {\n      const opTypeDefNode = operationTypes.find(operationType => operationType.operation === opTypeDefNodeType);\n      if (!opTypeDefNode) {\n        const possibleRootTypeName = schema_def_js_1.DEFAULT_OPERATION_TYPE_NAME_MAP[opTypeDefNodeType];\n        const existingPossibleRootType = mergedNodes[possibleRootTypeName];\n        if (existingPossibleRootType != null && existingPossibleRootType.name != null) {\n          operationTypes.push({\n            kind: graphql_1.Kind.OPERATION_TYPE_DEFINITION,\n            type: {\n              kind: graphql_1.Kind.NAMED_TYPE,\n              name: existingPossibleRootType.name\n            },\n            operation: opTypeDefNodeType\n          });\n        }\n      }\n    }\n    if (((_a = schemaDef === null || schemaDef === void 0 ? void 0 : schemaDef.operationTypes) === null || _a === void 0 ? void 0 : _a.length) != null && schemaDef.operationTypes.length > 0) {\n      mergedNodes[merge_nodes_js_1.schemaDefSymbol] = schemaDef;\n    }\n  }\n  if ((config === null || config === void 0 ? void 0 : config.forceSchemaDefinition) && !((_c = (_b = mergedNodes[merge_nodes_js_1.schemaDefSymbol]) === null || _b === void 0 ? void 0 : _b.operationTypes) === null || _c === void 0 ? void 0 : _c.length)) {\n    mergedNodes[merge_nodes_js_1.schemaDefSymbol] = {\n      kind: graphql_1.Kind.SCHEMA_DEFINITION,\n      operationTypes: [{\n        kind: graphql_1.Kind.OPERATION_TYPE_DEFINITION,\n        operation: 'query',\n        type: {\n          kind: graphql_1.Kind.NAMED_TYPE,\n          name: {\n            kind: graphql_1.Kind.NAME,\n            value: 'Query'\n          }\n        }\n      }]\n    };\n  }\n  const mergedNodeDefinitions = Object.values(mergedNodes);\n  if (config === null || config === void 0 ? void 0 : config.sort) {\n    const sortFn = typeof config.sort === 'function' ? config.sort : utils_js_1.defaultStringComparator;\n    mergedNodeDefinitions.sort((a, b) => {\n      var _a, _b;\n      return sortFn((_a = a.name) === null || _a === void 0 ? void 0 : _a.value, (_b = b.name) === null || _b === void 0 ? void 0 : _b.value);\n    });\n  }\n  return mergedNodeDefinitions;\n}\nexports.mergeGraphQLTypes = mergeGraphQLTypes;","map":{"version":3,"names":["Object","defineProperty","exports","value","mergeGraphQLTypes","mergeTypeDefs","graphql_1","require","utils_js_1","merge_nodes_js_1","utils_1","schema_def_js_1","typeSource","config","resetComments","doc","kind","Kind","DOCUMENT","definitions","useSchemaDefinition","forceSchemaDefinition","throwOnConflict","commentDescriptions","result","printWithComments","visitTypeSources","options","allNodes","arguments","length","undefined","visitedTypeSources","Set","has","add","Array","isArray","type","isSchema","documentNode","getDocumentNodeFromSchema","isStringTypes","isSourceTypes","parse","isDefinitionNode","push","isDocumentNode","Error","_a","_b","_c","mergedNodes","mergeGraphQLNodes","schemaDef","schemaDefSymbol","SCHEMA_DEFINITION","operationTypes","opTypeDefNodeType","DEFAULT_OPERATION_TYPE_NAME_MAP","opTypeDefNode","find","operationType","operation","possibleRootTypeName","existingPossibleRootType","name","OPERATION_TYPE_DEFINITION","NAMED_TYPE","NAME","mergedNodeDefinitions","values","sort","sortFn","defaultStringComparator","a","b"],"sources":["/Users/chadward/node_modules/@graphql-tools/merge/cjs/typedefs-mergers/merge-typedefs.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.mergeGraphQLTypes = exports.mergeTypeDefs = void 0;\nconst graphql_1 = require(\"graphql\");\nconst utils_js_1 = require(\"./utils.js\");\nconst merge_nodes_js_1 = require(\"./merge-nodes.js\");\nconst utils_1 = require(\"@graphql-tools/utils\");\nconst schema_def_js_1 = require(\"./schema-def.js\");\nfunction mergeTypeDefs(typeSource, config) {\n    (0, utils_1.resetComments)();\n    const doc = {\n        kind: graphql_1.Kind.DOCUMENT,\n        definitions: mergeGraphQLTypes(typeSource, {\n            useSchemaDefinition: true,\n            forceSchemaDefinition: false,\n            throwOnConflict: false,\n            commentDescriptions: false,\n            ...config,\n        }),\n    };\n    let result;\n    if (config === null || config === void 0 ? void 0 : config.commentDescriptions) {\n        result = (0, utils_1.printWithComments)(doc);\n    }\n    else {\n        result = doc;\n    }\n    (0, utils_1.resetComments)();\n    return result;\n}\nexports.mergeTypeDefs = mergeTypeDefs;\nfunction visitTypeSources(typeSource, options, allNodes = [], visitedTypeSources = new Set()) {\n    if (typeSource && !visitedTypeSources.has(typeSource)) {\n        visitedTypeSources.add(typeSource);\n        if (typeof typeSource === 'function') {\n            visitTypeSources(typeSource(), options, allNodes, visitedTypeSources);\n        }\n        else if (Array.isArray(typeSource)) {\n            for (const type of typeSource) {\n                visitTypeSources(type, options, allNodes, visitedTypeSources);\n            }\n        }\n        else if ((0, graphql_1.isSchema)(typeSource)) {\n            const documentNode = (0, utils_1.getDocumentNodeFromSchema)(typeSource, options);\n            visitTypeSources(documentNode.definitions, options, allNodes, visitedTypeSources);\n        }\n        else if ((0, utils_js_1.isStringTypes)(typeSource) || (0, utils_js_1.isSourceTypes)(typeSource)) {\n            const documentNode = (0, graphql_1.parse)(typeSource, options);\n            visitTypeSources(documentNode.definitions, options, allNodes, visitedTypeSources);\n        }\n        else if (typeof typeSource === 'object' && (0, graphql_1.isDefinitionNode)(typeSource)) {\n            allNodes.push(typeSource);\n        }\n        else if ((0, utils_1.isDocumentNode)(typeSource)) {\n            visitTypeSources(typeSource.definitions, options, allNodes, visitedTypeSources);\n        }\n        else {\n            throw new Error(`typeDefs must contain only strings, documents, schemas, or functions, got ${typeof typeSource}`);\n        }\n    }\n    return allNodes;\n}\nfunction mergeGraphQLTypes(typeSource, config) {\n    var _a, _b, _c;\n    (0, utils_1.resetComments)();\n    const allNodes = visitTypeSources(typeSource, config);\n    const mergedNodes = (0, merge_nodes_js_1.mergeGraphQLNodes)(allNodes, config);\n    if (config === null || config === void 0 ? void 0 : config.useSchemaDefinition) {\n        // XXX: right now we don't handle multiple schema definitions\n        const schemaDef = mergedNodes[merge_nodes_js_1.schemaDefSymbol] || {\n            kind: graphql_1.Kind.SCHEMA_DEFINITION,\n            operationTypes: [],\n        };\n        const operationTypes = schemaDef.operationTypes;\n        for (const opTypeDefNodeType in schema_def_js_1.DEFAULT_OPERATION_TYPE_NAME_MAP) {\n            const opTypeDefNode = operationTypes.find(operationType => operationType.operation === opTypeDefNodeType);\n            if (!opTypeDefNode) {\n                const possibleRootTypeName = schema_def_js_1.DEFAULT_OPERATION_TYPE_NAME_MAP[opTypeDefNodeType];\n                const existingPossibleRootType = mergedNodes[possibleRootTypeName];\n                if (existingPossibleRootType != null && existingPossibleRootType.name != null) {\n                    operationTypes.push({\n                        kind: graphql_1.Kind.OPERATION_TYPE_DEFINITION,\n                        type: {\n                            kind: graphql_1.Kind.NAMED_TYPE,\n                            name: existingPossibleRootType.name,\n                        },\n                        operation: opTypeDefNodeType,\n                    });\n                }\n            }\n        }\n        if (((_a = schemaDef === null || schemaDef === void 0 ? void 0 : schemaDef.operationTypes) === null || _a === void 0 ? void 0 : _a.length) != null && schemaDef.operationTypes.length > 0) {\n            mergedNodes[merge_nodes_js_1.schemaDefSymbol] = schemaDef;\n        }\n    }\n    if ((config === null || config === void 0 ? void 0 : config.forceSchemaDefinition) && !((_c = (_b = mergedNodes[merge_nodes_js_1.schemaDefSymbol]) === null || _b === void 0 ? void 0 : _b.operationTypes) === null || _c === void 0 ? void 0 : _c.length)) {\n        mergedNodes[merge_nodes_js_1.schemaDefSymbol] = {\n            kind: graphql_1.Kind.SCHEMA_DEFINITION,\n            operationTypes: [\n                {\n                    kind: graphql_1.Kind.OPERATION_TYPE_DEFINITION,\n                    operation: 'query',\n                    type: {\n                        kind: graphql_1.Kind.NAMED_TYPE,\n                        name: {\n                            kind: graphql_1.Kind.NAME,\n                            value: 'Query',\n                        },\n                    },\n                },\n            ],\n        };\n    }\n    const mergedNodeDefinitions = Object.values(mergedNodes);\n    if (config === null || config === void 0 ? void 0 : config.sort) {\n        const sortFn = typeof config.sort === 'function' ? config.sort : utils_js_1.defaultStringComparator;\n        mergedNodeDefinitions.sort((a, b) => { var _a, _b; return sortFn((_a = a.name) === null || _a === void 0 ? void 0 : _a.value, (_b = b.name) === null || _b === void 0 ? void 0 : _b.value); });\n    }\n    return mergedNodeDefinitions;\n}\nexports.mergeGraphQLTypes = mergeGraphQLTypes;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}