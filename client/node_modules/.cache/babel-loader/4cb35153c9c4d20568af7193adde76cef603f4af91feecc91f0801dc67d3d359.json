{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.OurContextualizedStats = exports.OurReport = exports.SizeEstimator = void 0;\nconst durationHistogram_1 = require(\"./durationHistogram\");\nconst apollo_reporting_protobuf_1 = require(\"apollo-reporting-protobuf\");\nconst iterateOverTrace_1 = require(\"./iterateOverTrace\");\nclass SizeEstimator {\n  constructor() {\n    this.bytes = 0;\n  }\n}\nexports.SizeEstimator = SizeEstimator;\nclass OurReport {\n  constructor(header) {\n    this.header = header;\n    this.tracesPreAggregated = false;\n    this.tracesPerQuery = Object.create(null);\n    this.endTime = null;\n    this.operationCount = 0;\n    this.sizeEstimator = new SizeEstimator();\n  }\n  ensureCountsAreIntegers() {\n    for (const tracesAndStats of Object.values(this.tracesPerQuery)) {\n      tracesAndStats.ensureCountsAreIntegers();\n    }\n  }\n  addTrace(_ref) {\n    let {\n      statsReportKey,\n      trace,\n      asTrace,\n      includeTracesContributingToStats,\n      referencedFieldsByType\n    } = _ref;\n    const tracesAndStats = this.getTracesAndStats({\n      statsReportKey,\n      referencedFieldsByType\n    });\n    if (asTrace) {\n      const encodedTrace = apollo_reporting_protobuf_1.Trace.encode(trace).finish();\n      tracesAndStats.trace.push(encodedTrace);\n      this.sizeEstimator.bytes += 2 + encodedTrace.length;\n    } else {\n      tracesAndStats.statsWithContext.addTrace(trace, this.sizeEstimator);\n      if (includeTracesContributingToStats) {\n        const encodedTrace = apollo_reporting_protobuf_1.Trace.encode(trace).finish();\n        tracesAndStats.internalTracesContributingToStats.push(encodedTrace);\n        this.sizeEstimator.bytes += 2 + encodedTrace.length;\n      }\n    }\n  }\n  getTracesAndStats(_ref2) {\n    let {\n      statsReportKey,\n      referencedFieldsByType\n    } = _ref2;\n    const existing = this.tracesPerQuery[statsReportKey];\n    if (existing) {\n      return existing;\n    }\n    this.sizeEstimator.bytes += estimatedBytesForString(statsReportKey);\n    for (const [typeName, referencedFieldsForType] of Object.entries(referencedFieldsByType)) {\n      this.sizeEstimator.bytes += 2 + 2;\n      if (referencedFieldsForType.isInterface) {\n        this.sizeEstimator.bytes += 2;\n      }\n      this.sizeEstimator.bytes += estimatedBytesForString(typeName);\n      for (const fieldName of referencedFieldsForType.fieldNames) {\n        this.sizeEstimator.bytes += estimatedBytesForString(fieldName);\n      }\n    }\n    return this.tracesPerQuery[statsReportKey] = new OurTracesAndStats(referencedFieldsByType);\n  }\n}\nexports.OurReport = OurReport;\nclass OurTracesAndStats {\n  constructor(referencedFieldsByType) {\n    this.referencedFieldsByType = referencedFieldsByType;\n    this.trace = [];\n    this.statsWithContext = new StatsByContext();\n    this.internalTracesContributingToStats = [];\n  }\n  ensureCountsAreIntegers() {\n    this.statsWithContext.ensureCountsAreIntegers();\n  }\n}\nclass StatsByContext {\n  constructor() {\n    this.map = Object.create(null);\n  }\n  toArray() {\n    return Object.values(this.map);\n  }\n  ensureCountsAreIntegers() {\n    for (const contextualizedStats of Object.values(this.map)) {\n      contextualizedStats.ensureCountsAreIntegers();\n    }\n  }\n  addTrace(trace, sizeEstimator) {\n    this.getContextualizedStats(trace, sizeEstimator).addTrace(trace, sizeEstimator);\n  }\n  getContextualizedStats(trace, sizeEstimator) {\n    const statsContext = {\n      clientName: trace.clientName,\n      clientVersion: trace.clientVersion\n    };\n    const statsContextKey = JSON.stringify(statsContext);\n    const existing = this.map[statsContextKey];\n    if (existing) {\n      return existing;\n    }\n    sizeEstimator.bytes += 20 + estimatedBytesForString(trace.clientName) + estimatedBytesForString(trace.clientVersion);\n    const contextualizedStats = new OurContextualizedStats(statsContext);\n    this.map[statsContextKey] = contextualizedStats;\n    return contextualizedStats;\n  }\n}\nclass OurContextualizedStats {\n  constructor(context) {\n    this.context = context;\n    this.queryLatencyStats = new OurQueryLatencyStats();\n    this.perTypeStat = Object.create(null);\n  }\n  ensureCountsAreIntegers() {\n    for (const typeStat of Object.values(this.perTypeStat)) {\n      typeStat.ensureCountsAreIntegers();\n    }\n  }\n  addTrace(trace, sizeEstimator) {\n    var _a;\n    const {\n      fieldExecutionWeight\n    } = trace;\n    if (!fieldExecutionWeight) {\n      this.queryLatencyStats.requestsWithoutFieldInstrumentation++;\n    }\n    this.queryLatencyStats.requestCount++;\n    if (trace.fullQueryCacheHit) {\n      this.queryLatencyStats.cacheLatencyCount.incrementDuration(trace.durationNs);\n      this.queryLatencyStats.cacheHits++;\n    } else {\n      this.queryLatencyStats.latencyCount.incrementDuration(trace.durationNs);\n    }\n    if (!trace.fullQueryCacheHit && ((_a = trace.cachePolicy) === null || _a === void 0 ? void 0 : _a.maxAgeNs) != null) {\n      switch (trace.cachePolicy.scope) {\n        case apollo_reporting_protobuf_1.Trace.CachePolicy.Scope.PRIVATE:\n          this.queryLatencyStats.privateCacheTtlCount.incrementDuration(trace.cachePolicy.maxAgeNs);\n          break;\n        case apollo_reporting_protobuf_1.Trace.CachePolicy.Scope.PUBLIC:\n          this.queryLatencyStats.publicCacheTtlCount.incrementDuration(trace.cachePolicy.maxAgeNs);\n          break;\n      }\n    }\n    if (trace.persistedQueryHit) {\n      this.queryLatencyStats.persistedQueryHits++;\n    }\n    if (trace.persistedQueryRegister) {\n      this.queryLatencyStats.persistedQueryMisses++;\n    }\n    if (trace.forbiddenOperation) {\n      this.queryLatencyStats.forbiddenOperationCount++;\n    }\n    if (trace.registeredOperation) {\n      this.queryLatencyStats.registeredOperationCount++;\n    }\n    let hasError = false;\n    const traceNodeStats = (node, path) => {\n      var _a, _b, _c, _d, _e;\n      if ((_a = node.error) === null || _a === void 0 ? void 0 : _a.length) {\n        hasError = true;\n        let currPathErrorStats = this.queryLatencyStats.rootErrorStats;\n        path.toArray().forEach(subPath => {\n          currPathErrorStats = currPathErrorStats.getChild(subPath, sizeEstimator);\n        });\n        currPathErrorStats.requestsWithErrorsCount += 1;\n        currPathErrorStats.errorsCount += node.error.length;\n      }\n      if (fieldExecutionWeight) {\n        const fieldName = node.originalFieldName || node.responseName;\n        if (node.parentType && fieldName && node.type && node.endTime != null && node.startTime != null && node.endTime >= node.startTime) {\n          const typeStat = this.getTypeStat(node.parentType, sizeEstimator);\n          const fieldStat = typeStat.getFieldStat(fieldName, node.type, sizeEstimator);\n          fieldStat.errorsCount += (_c = (_b = node.error) === null || _b === void 0 ? void 0 : _b.length) !== null && _c !== void 0 ? _c : 0;\n          fieldStat.observedExecutionCount++;\n          fieldStat.estimatedExecutionCount += fieldExecutionWeight;\n          fieldStat.requestsWithErrorsCount += ((_e = (_d = node.error) === null || _d === void 0 ? void 0 : _d.length) !== null && _e !== void 0 ? _e : 0) > 0 ? 1 : 0;\n          fieldStat.latencyCount.incrementDuration(node.endTime - node.startTime, fieldExecutionWeight);\n        }\n      }\n      return false;\n    };\n    (0, iterateOverTrace_1.iterateOverTrace)(trace, traceNodeStats, true);\n    if (hasError) {\n      this.queryLatencyStats.requestsWithErrorsCount++;\n    }\n  }\n  getTypeStat(parentType, sizeEstimator) {\n    const existing = this.perTypeStat[parentType];\n    if (existing) {\n      return existing;\n    }\n    sizeEstimator.bytes += estimatedBytesForString(parentType);\n    const typeStat = new OurTypeStat();\n    this.perTypeStat[parentType] = typeStat;\n    return typeStat;\n  }\n}\nexports.OurContextualizedStats = OurContextualizedStats;\nclass OurQueryLatencyStats {\n  constructor() {\n    this.latencyCount = new durationHistogram_1.DurationHistogram();\n    this.requestCount = 0;\n    this.requestsWithoutFieldInstrumentation = 0;\n    this.cacheHits = 0;\n    this.persistedQueryHits = 0;\n    this.persistedQueryMisses = 0;\n    this.cacheLatencyCount = new durationHistogram_1.DurationHistogram();\n    this.rootErrorStats = new OurPathErrorStats();\n    this.requestsWithErrorsCount = 0;\n    this.publicCacheTtlCount = new durationHistogram_1.DurationHistogram();\n    this.privateCacheTtlCount = new durationHistogram_1.DurationHistogram();\n    this.registeredOperationCount = 0;\n    this.forbiddenOperationCount = 0;\n  }\n}\nclass OurPathErrorStats {\n  constructor() {\n    this.children = Object.create(null);\n    this.errorsCount = 0;\n    this.requestsWithErrorsCount = 0;\n  }\n  getChild(subPath, sizeEstimator) {\n    const existing = this.children[subPath];\n    if (existing) {\n      return existing;\n    }\n    const child = new OurPathErrorStats();\n    this.children[subPath] = child;\n    sizeEstimator.bytes += estimatedBytesForString(subPath) + 4;\n    return child;\n  }\n}\nclass OurTypeStat {\n  constructor() {\n    this.perFieldStat = Object.create(null);\n  }\n  getFieldStat(fieldName, returnType, sizeEstimator) {\n    const existing = this.perFieldStat[fieldName];\n    if (existing) {\n      return existing;\n    }\n    sizeEstimator.bytes += estimatedBytesForString(fieldName) + estimatedBytesForString(returnType) + 10;\n    const fieldStat = new OurFieldStat(returnType);\n    this.perFieldStat[fieldName] = fieldStat;\n    return fieldStat;\n  }\n  ensureCountsAreIntegers() {\n    for (const fieldStat of Object.values(this.perFieldStat)) {\n      fieldStat.ensureCountsAreIntegers();\n    }\n  }\n}\nclass OurFieldStat {\n  constructor(returnType) {\n    this.returnType = returnType;\n    this.errorsCount = 0;\n    this.observedExecutionCount = 0;\n    this.estimatedExecutionCount = 0;\n    this.requestsWithErrorsCount = 0;\n    this.latencyCount = new durationHistogram_1.DurationHistogram();\n  }\n  ensureCountsAreIntegers() {\n    this.estimatedExecutionCount = Math.floor(this.estimatedExecutionCount);\n  }\n}\nfunction estimatedBytesForString(s) {\n  return 2 + Buffer.byteLength(s);\n}","map":{"version":3,"names":["durationHistogram_1","require","apollo_reporting_protobuf_1","iterateOverTrace_1","SizeEstimator","constructor","bytes","exports","OurReport","header","tracesPreAggregated","tracesPerQuery","Object","create","endTime","operationCount","sizeEstimator","ensureCountsAreIntegers","tracesAndStats","values","addTrace","_ref","statsReportKey","trace","asTrace","includeTracesContributingToStats","referencedFieldsByType","getTracesAndStats","encodedTrace","Trace","encode","finish","push","length","statsWithContext","internalTracesContributingToStats","_ref2","existing","estimatedBytesForString","typeName","referencedFieldsForType","entries","isInterface","fieldName","fieldNames","OurTracesAndStats","StatsByContext","map","toArray","contextualizedStats","getContextualizedStats","statsContext","clientName","clientVersion","statsContextKey","JSON","stringify","OurContextualizedStats","context","queryLatencyStats","OurQueryLatencyStats","perTypeStat","typeStat","fieldExecutionWeight","requestsWithoutFieldInstrumentation","requestCount","fullQueryCacheHit","cacheLatencyCount","incrementDuration","durationNs","cacheHits","latencyCount","_a","cachePolicy","maxAgeNs","scope","CachePolicy","Scope","PRIVATE","privateCacheTtlCount","PUBLIC","publicCacheTtlCount","persistedQueryHit","persistedQueryHits","persistedQueryRegister","persistedQueryMisses","forbiddenOperation","forbiddenOperationCount","registeredOperation","registeredOperationCount","hasError","traceNodeStats","node","path","error","currPathErrorStats","rootErrorStats","forEach","subPath","getChild","requestsWithErrorsCount","errorsCount","originalFieldName","responseName","parentType","type","startTime","getTypeStat","fieldStat","getFieldStat","_c","_b","observedExecutionCount","estimatedExecutionCount","_e","_d","iterateOverTrace","OurTypeStat","DurationHistogram","OurPathErrorStats","children","child","perFieldStat","returnType","OurFieldStat","Math","floor","s","Buffer","byteLength"],"sources":["/Users/chadward/node_modules/apollo-server-core/src/plugin/usageReporting/stats.ts"],"sourcesContent":["import { DurationHistogram } from './durationHistogram';\nimport {\n  IFieldStat,\n  IPathErrorStats,\n  IQueryLatencyStats,\n  IStatsContext,\n  Trace,\n  ITypeStat,\n  IContextualizedStats,\n  ReportHeader,\n  google,\n  ITracesAndStats,\n  IReport,\n} from 'apollo-reporting-protobuf';\nimport { iterateOverTrace, ResponseNamePath } from './iterateOverTrace';\nimport type { ReferencedFieldsByType } from '@apollo/utils.usagereporting';\n\n// protobuf.js exports both a class and an interface (starting with I) for each\n// message type. The class is what it produces when it decodes the message; the\n// interface is what is accepted as input. We build up our messages using custom\n// types implementing the interfaces, so that we can take advantage of the\n// js_use_toArray option we added to our protobuf.js fork which allows us to use\n// classes like DurationHistogram to generate repeated fields. We end up\n// re-creating most of the report structure as custom classes (starting with\n// \"Our\"). TypeScript validates that we've properly listed all of the message\n// fields with the appropriate types (we use `Required` to ensure we implement\n// all message fields). Using our own classes has other advantages, like being\n// able to specify that nested messages are instances of the same class rather\n// than the interface type and thus that they have non-null fields (because the\n// interface type allows all fields to be optional, even though the protobuf\n// format doesn't differentiate between missing and falsey).\n\nexport class SizeEstimator {\n  bytes = 0;\n}\nexport class OurReport implements Required<IReport> {\n  // Apollo Server includes each operation either as aggregated stats or as a\n  // trace, but not both. Other reporting agents such as Apollo Router include\n  // all operations in stats (even those that are sent as traces), and they set\n  // this flag to true.\n  tracesPreAggregated = false;\n\n  constructor(readonly header: ReportHeader) {}\n  readonly tracesPerQuery: Record<string, OurTracesAndStats> =\n    Object.create(null);\n  endTime: google.protobuf.ITimestamp | null = null;\n  operationCount = 0;\n  // A rough estimate of the number of bytes currently in the report. We start\n  // at zero and don't count `header` and `endTime`, which have the same size\n  // for every report. This really is a rough estimate, so we don't stress too\n  // much about counting bytes for the tags and string/message lengths, etc:\n  // we mostly just count the lengths of strings plus some estimates for the\n  // messages with a bunch of numbers in them.\n  //\n  // We store this in a class so we can pass it down as a reference to other\n  // methods which increment it.\n  readonly sizeEstimator = new SizeEstimator();\n\n  ensureCountsAreIntegers() {\n    for (const tracesAndStats of Object.values(this.tracesPerQuery)) {\n      tracesAndStats.ensureCountsAreIntegers();\n    }\n  }\n\n  addTrace({\n    statsReportKey,\n    trace,\n    asTrace,\n    includeTracesContributingToStats,\n    referencedFieldsByType,\n  }: {\n    statsReportKey: string;\n    trace: Trace;\n    asTrace: boolean;\n    includeTracesContributingToStats: boolean;\n    referencedFieldsByType: ReferencedFieldsByType;\n  }) {\n    const tracesAndStats = this.getTracesAndStats({\n      statsReportKey,\n      referencedFieldsByType,\n    });\n    if (asTrace) {\n      const encodedTrace = Trace.encode(trace).finish();\n      tracesAndStats.trace.push(encodedTrace);\n      this.sizeEstimator.bytes += 2 + encodedTrace.length;\n    } else {\n      tracesAndStats.statsWithContext.addTrace(trace, this.sizeEstimator);\n      if (includeTracesContributingToStats) {\n        // For specific use inside Apollo's infrastructure to help validate that\n        // the code in this file matches similar code in Apollo's servers,\n        // include the traces that contribute to the stats. Doing this outside\n        // of Apollo's infrastructure only serves to make reports larger with no\n        // other advantage.\n        const encodedTrace = Trace.encode(trace).finish();\n        tracesAndStats.internalTracesContributingToStats.push(encodedTrace);\n        this.sizeEstimator.bytes += 2 + encodedTrace.length;\n      }\n    }\n  }\n\n  private getTracesAndStats({\n    statsReportKey,\n    referencedFieldsByType,\n  }: {\n    statsReportKey: string;\n    referencedFieldsByType: ReferencedFieldsByType;\n  }) {\n    const existing = this.tracesPerQuery[statsReportKey];\n    if (existing) {\n      return existing;\n    }\n    this.sizeEstimator.bytes += estimatedBytesForString(statsReportKey);\n\n    // Update the size estimator for the referenced field structure.\n    for (const [typeName, referencedFieldsForType] of Object.entries(\n      referencedFieldsByType,\n    )) {\n      // Two bytes each for the map entry and for the ReferencedFieldsForType,\n      // and for the isInterface bool if it's set.\n      this.sizeEstimator.bytes += 2 + 2;\n      if (referencedFieldsForType.isInterface) {\n        this.sizeEstimator.bytes += 2;\n      }\n      this.sizeEstimator.bytes += estimatedBytesForString(typeName);\n      for (const fieldName of referencedFieldsForType.fieldNames) {\n        this.sizeEstimator.bytes += estimatedBytesForString(fieldName);\n      }\n    }\n\n    // Include the referenced fields map in the report. (In an ideal world we\n    // could have a slightly more sophisticated protocol and ingestion pipeline\n    // that allowed us to only have to send this data once for each\n    // schema/operation pair.)\n    return (this.tracesPerQuery[statsReportKey] = new OurTracesAndStats(\n      referencedFieldsByType,\n    ));\n  }\n}\n\nclass OurTracesAndStats implements Required<ITracesAndStats> {\n  constructor(readonly referencedFieldsByType: ReferencedFieldsByType) {}\n  readonly trace: Uint8Array[] = [];\n  readonly statsWithContext = new StatsByContext();\n  readonly internalTracesContributingToStats: Uint8Array[] = [];\n\n  ensureCountsAreIntegers() {\n    this.statsWithContext.ensureCountsAreIntegers();\n  }\n}\n\nclass StatsByContext {\n  readonly map: { [k: string]: OurContextualizedStats } = Object.create(null);\n\n  /**\n   * This function is used by the protobuf generator to convert this map into\n   * an array of contextualized stats to serialize\n   */\n  toArray(): IContextualizedStats[] {\n    return Object.values(this.map);\n  }\n\n  ensureCountsAreIntegers() {\n    for (const contextualizedStats of Object.values(this.map)) {\n      contextualizedStats.ensureCountsAreIntegers();\n    }\n  }\n\n  addTrace(trace: Trace, sizeEstimator: SizeEstimator) {\n    this.getContextualizedStats(trace, sizeEstimator).addTrace(\n      trace,\n      sizeEstimator,\n    );\n  }\n\n  private getContextualizedStats(\n    trace: Trace,\n    sizeEstimator: SizeEstimator,\n  ): OurContextualizedStats {\n    const statsContext: IStatsContext = {\n      clientName: trace.clientName,\n      clientVersion: trace.clientVersion,\n    };\n    const statsContextKey = JSON.stringify(statsContext);\n\n    const existing = this.map[statsContextKey];\n    if (existing) {\n      return existing;\n    }\n    // Adding a ContextualizedStats means adding a StatsContext plus a\n    // QueryLatencyStats. Let's guess about 20 bytes for a QueryLatencyStats;\n    // it'll be more if more features are used (like cache, APQ, etc).\n    sizeEstimator.bytes +=\n      20 +\n      estimatedBytesForString(trace.clientName) +\n      estimatedBytesForString(trace.clientVersion);\n    const contextualizedStats = new OurContextualizedStats(statsContext);\n    this.map[statsContextKey] = contextualizedStats;\n    return contextualizedStats;\n  }\n}\n\nexport class OurContextualizedStats implements Required<IContextualizedStats> {\n  queryLatencyStats = new OurQueryLatencyStats();\n  perTypeStat: { [k: string]: OurTypeStat } = Object.create(null);\n\n  constructor(readonly context: IStatsContext) {}\n\n  ensureCountsAreIntegers() {\n    for (const typeStat of Object.values(this.perTypeStat)) {\n      typeStat.ensureCountsAreIntegers();\n    }\n  }\n\n  // Extract statistics from the trace, and increment the estimated report size.\n  // We only add to the estimate when adding whole sub-messages. If it really\n  // mattered, we could do a lot more careful things like incrementing it\n  // whenever a numeric field on queryLatencyStats gets incremented over 0.\n  addTrace(trace: Trace, sizeEstimator: SizeEstimator) {\n    const { fieldExecutionWeight } = trace;\n    if (!fieldExecutionWeight) {\n      this.queryLatencyStats.requestsWithoutFieldInstrumentation++;\n    }\n\n    this.queryLatencyStats.requestCount++;\n    if (trace.fullQueryCacheHit) {\n      this.queryLatencyStats.cacheLatencyCount.incrementDuration(\n        trace.durationNs,\n      );\n      this.queryLatencyStats.cacheHits++;\n    } else {\n      this.queryLatencyStats.latencyCount.incrementDuration(trace.durationNs);\n    }\n\n    // We only provide stats about cache TTLs on cache misses (ie, TTLs directly\n    // calculated by the backend), not for cache hits. This matches the\n    // behavior we've had for a while when converting traces into statistics\n    // in Studio's servers.\n    if (!trace.fullQueryCacheHit && trace.cachePolicy?.maxAgeNs != null) {\n      switch (trace.cachePolicy.scope) {\n        case Trace.CachePolicy.Scope.PRIVATE:\n          this.queryLatencyStats.privateCacheTtlCount.incrementDuration(\n            trace.cachePolicy.maxAgeNs,\n          );\n          break;\n        case Trace.CachePolicy.Scope.PUBLIC:\n          this.queryLatencyStats.publicCacheTtlCount.incrementDuration(\n            trace.cachePolicy.maxAgeNs,\n          );\n          break;\n      }\n    }\n\n    if (trace.persistedQueryHit) {\n      this.queryLatencyStats.persistedQueryHits++;\n    }\n    if (trace.persistedQueryRegister) {\n      this.queryLatencyStats.persistedQueryMisses++;\n    }\n\n    if (trace.forbiddenOperation) {\n      this.queryLatencyStats.forbiddenOperationCount++;\n    }\n    if (trace.registeredOperation) {\n      this.queryLatencyStats.registeredOperationCount++;\n    }\n\n    let hasError = false;\n\n    const traceNodeStats = (node: Trace.INode, path: ResponseNamePath) => {\n      // Generate error stats and error path information\n      if (node.error?.length) {\n        hasError = true;\n\n        let currPathErrorStats = this.queryLatencyStats.rootErrorStats;\n        path.toArray().forEach((subPath) => {\n          currPathErrorStats = currPathErrorStats.getChild(\n            subPath,\n            sizeEstimator,\n          );\n        });\n\n        currPathErrorStats.requestsWithErrorsCount += 1;\n        currPathErrorStats.errorsCount += node.error.length;\n      }\n\n      if (fieldExecutionWeight) {\n        // The actual field name behind the node; originalFieldName is set\n        // if an alias was used, otherwise responseName. (This is falsey for\n        // nodes that are not fields (root, array index, etc).)\n        const fieldName = node.originalFieldName || node.responseName;\n\n        // Protobuf doesn't really differentiate between \"unset\" and \"falsey\" so\n        // we're mostly actually checking that these things are non-empty string /\n        // non-zero numbers. The time fields represent the number of nanoseconds\n        // since the beginning of the entire trace, so let's pretend for the\n        // moment that it's plausible for a node to start or even end exactly when\n        // the trace started (ie, for the time values to be 0). This is unlikely\n        // in practice (everything should take at least 1ns). In practice we only\n        // write `type` and `parentType` on a Node when we write `startTime`, so\n        // the main thing we're looking out for by checking the time values is\n        // whether we somehow failed to write `endTime` at the end of the field;\n        // in this case, the `endTime >= startTime` check won't match.\n        if (\n          node.parentType &&\n          fieldName &&\n          node.type &&\n          node.endTime != null &&\n          node.startTime != null &&\n          node.endTime >= node.startTime\n        ) {\n          const typeStat = this.getTypeStat(node.parentType, sizeEstimator);\n\n          const fieldStat = typeStat.getFieldStat(\n            fieldName,\n            node.type,\n            sizeEstimator,\n          );\n\n          fieldStat.errorsCount += node.error?.length ?? 0;\n          fieldStat.observedExecutionCount++;\n          fieldStat.estimatedExecutionCount += fieldExecutionWeight;\n          // Note: this is actually counting the number of resolver calls for this\n          // field that had at least one error, not the number of overall GraphQL\n          // queries that had at least one error for this field. That doesn't seem\n          // to match the name, but it does match the other implementations of this\n          // logic.\n          fieldStat.requestsWithErrorsCount +=\n            (node.error?.length ?? 0) > 0 ? 1 : 0;\n          fieldStat.latencyCount.incrementDuration(\n            node.endTime - node.startTime,\n            // The latency histogram is always \"estimated\"; we don't track\n            // \"observed\" and \"estimated\" separately.\n            fieldExecutionWeight,\n          );\n        }\n      }\n\n      return false;\n    };\n\n    iterateOverTrace(trace, traceNodeStats, true);\n    if (hasError) {\n      this.queryLatencyStats.requestsWithErrorsCount++;\n    }\n  }\n\n  getTypeStat(parentType: string, sizeEstimator: SizeEstimator): OurTypeStat {\n    const existing = this.perTypeStat[parentType];\n    if (existing) {\n      return existing;\n    }\n    sizeEstimator.bytes += estimatedBytesForString(parentType);\n    const typeStat = new OurTypeStat();\n    this.perTypeStat[parentType] = typeStat;\n    return typeStat;\n  }\n}\n\nclass OurQueryLatencyStats implements Required<IQueryLatencyStats> {\n  latencyCount: DurationHistogram = new DurationHistogram();\n  requestCount: number = 0;\n  requestsWithoutFieldInstrumentation: number = 0;\n  cacheHits: number = 0;\n  persistedQueryHits: number = 0;\n  persistedQueryMisses: number = 0;\n  cacheLatencyCount: DurationHistogram = new DurationHistogram();\n  rootErrorStats: OurPathErrorStats = new OurPathErrorStats();\n  requestsWithErrorsCount: number = 0;\n  publicCacheTtlCount: DurationHistogram = new DurationHistogram();\n  privateCacheTtlCount: DurationHistogram = new DurationHistogram();\n  registeredOperationCount: number = 0;\n  forbiddenOperationCount: number = 0;\n}\n\nclass OurPathErrorStats implements Required<IPathErrorStats> {\n  children: { [k: string]: OurPathErrorStats } = Object.create(null);\n  errorsCount: number = 0;\n  requestsWithErrorsCount: number = 0;\n\n  getChild(subPath: string, sizeEstimator: SizeEstimator): OurPathErrorStats {\n    const existing = this.children[subPath];\n    if (existing) {\n      return existing;\n    }\n    const child = new OurPathErrorStats();\n    this.children[subPath] = child;\n    // Include a few bytes in the estimate for the numbers etc.\n    sizeEstimator.bytes += estimatedBytesForString(subPath) + 4;\n    return child;\n  }\n}\n\nclass OurTypeStat implements Required<ITypeStat> {\n  perFieldStat: { [k: string]: OurFieldStat } = Object.create(null);\n\n  getFieldStat(\n    fieldName: string,\n    returnType: string,\n    sizeEstimator: SizeEstimator,\n  ): OurFieldStat {\n    const existing = this.perFieldStat[fieldName];\n    if (existing) {\n      return existing;\n    }\n    // Rough estimate of 10 bytes for the numbers in the FieldStat.\n    sizeEstimator.bytes +=\n      estimatedBytesForString(fieldName) +\n      estimatedBytesForString(returnType) +\n      10;\n    const fieldStat = new OurFieldStat(returnType);\n    this.perFieldStat[fieldName] = fieldStat;\n    return fieldStat;\n  }\n\n  ensureCountsAreIntegers() {\n    for (const fieldStat of Object.values(this.perFieldStat)) {\n      fieldStat.ensureCountsAreIntegers();\n    }\n  }\n}\n\nclass OurFieldStat implements Required<IFieldStat> {\n  errorsCount: number = 0;\n  observedExecutionCount: number = 0;\n  // Note that this number isn't necessarily an integer while it is being\n  // aggregated. Before encoding as a protobuf we call ensureCountsAreIntegers\n  // which floors it.\n  estimatedExecutionCount: number = 0;\n  requestsWithErrorsCount: number = 0;\n  latencyCount: DurationHistogram = new DurationHistogram();\n\n  constructor(readonly returnType: string) {}\n\n  ensureCountsAreIntegers() {\n    // This is the only one that ever can receive non-integers.\n    this.estimatedExecutionCount = Math.floor(this.estimatedExecutionCount);\n  }\n}\n\nfunction estimatedBytesForString(s: string) {\n  // 2 is for the tag (field ID + wire type) plus the encoded length. (The\n  // encoded length takes up more than 1 byte for strings that are longer than\n  // 127 bytes, but this is an estimate.)\n  return 2 + Buffer.byteLength(s);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}