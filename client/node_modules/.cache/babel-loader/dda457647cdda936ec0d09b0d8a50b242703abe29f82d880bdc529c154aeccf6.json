{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getBlockStringIndentation = exports.dedentBlockStringValue = exports.getLeadingCommentBlock = exports.getComment = exports.getDescription = exports.printWithComments = exports.printComment = exports.pushComment = exports.collectComment = exports.resetComments = void 0;\nconst graphql_1 = require(\"graphql\");\nconst MAX_LINE_LENGTH = 80;\nlet commentsRegistry = {};\nfunction resetComments() {\n  commentsRegistry = {};\n}\nexports.resetComments = resetComments;\nfunction collectComment(node) {\n  var _a;\n  const entityName = (_a = node.name) === null || _a === void 0 ? void 0 : _a.value;\n  if (entityName == null) {\n    return;\n  }\n  pushComment(node, entityName);\n  switch (node.kind) {\n    case 'EnumTypeDefinition':\n      if (node.values) {\n        for (const value of node.values) {\n          pushComment(value, entityName, value.name.value);\n        }\n      }\n      break;\n    case 'ObjectTypeDefinition':\n    case 'InputObjectTypeDefinition':\n    case 'InterfaceTypeDefinition':\n      if (node.fields) {\n        for (const field of node.fields) {\n          pushComment(field, entityName, field.name.value);\n          if (isFieldDefinitionNode(field) && field.arguments) {\n            for (const arg of field.arguments) {\n              pushComment(arg, entityName, field.name.value, arg.name.value);\n            }\n          }\n        }\n      }\n      break;\n  }\n}\nexports.collectComment = collectComment;\nfunction pushComment(node, entity, field, argument) {\n  const comment = getComment(node);\n  if (typeof comment !== 'string' || comment.length === 0) {\n    return;\n  }\n  const keys = [entity];\n  if (field) {\n    keys.push(field);\n    if (argument) {\n      keys.push(argument);\n    }\n  }\n  const path = keys.join('.');\n  if (!commentsRegistry[path]) {\n    commentsRegistry[path] = [];\n  }\n  commentsRegistry[path].push(comment);\n}\nexports.pushComment = pushComment;\nfunction printComment(comment) {\n  return '\\n# ' + comment.replace(/\\n/g, '\\n# ');\n}\nexports.printComment = printComment;\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n/**\n * NOTE: ==> This file has been modified just to add comments to the printed AST\n * This is a temp measure, we will move to using the original non modified printer.js ASAP.\n */\n/**\n * Given maybeArray, print an empty string if it is null or empty, otherwise\n * print all items together separated by separator if provided\n */\nfunction join(maybeArray, separator) {\n  return maybeArray ? maybeArray.filter(x => x).join(separator || '') : '';\n}\nfunction hasMultilineItems(maybeArray) {\n  var _a;\n  return (_a = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.some(str => str.includes('\\n'))) !== null && _a !== void 0 ? _a : false;\n}\nfunction addDescription(cb) {\n  return (node, _key, _parent, path, ancestors) => {\n    var _a;\n    const keys = [];\n    const parent = path.reduce((prev, key) => {\n      if (['fields', 'arguments', 'values'].includes(key) && prev.name) {\n        keys.push(prev.name.value);\n      }\n      return prev[key];\n    }, ancestors[0]);\n    const key = [...keys, (_a = parent === null || parent === void 0 ? void 0 : parent.name) === null || _a === void 0 ? void 0 : _a.value].filter(Boolean).join('.');\n    const items = [];\n    if (node.kind.includes('Definition') && commentsRegistry[key]) {\n      items.push(...commentsRegistry[key]);\n    }\n    return join([...items.map(printComment), node.description, cb(node, _key, _parent, path, ancestors)], '\\n');\n  };\n}\nfunction indent(maybeString) {\n  return maybeString && `  ${maybeString.replace(/\\n/g, '\\n  ')}`;\n}\n/**\n * Given array, print each item on its own line, wrapped in an\n * indented \"{ }\" block.\n */\nfunction block(array) {\n  return array && array.length !== 0 ? `{\\n${indent(join(array, '\\n'))}\\n}` : '';\n}\n/**\n * If maybeString is not null or empty, then wrap with start and end, otherwise\n * print an empty string.\n */\nfunction wrap(start, maybeString, end) {\n  return maybeString ? start + maybeString + (end || '') : '';\n}\n/**\n * Print a block string in the indented block form by adding a leading and\n * trailing blank line. However, if a block string starts with whitespace and is\n * a single-line, adding a leading blank line would strip that whitespace.\n */\nfunction printBlockString(value) {\n  let isDescription = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  const escaped = value.replace(/\"\"\"/g, '\\\\\"\"\"');\n  return (value[0] === ' ' || value[0] === '\\t') && value.indexOf('\\n') === -1 ? `\"\"\"${escaped.replace(/\"$/, '\"\\n')}\"\"\"` : `\"\"\"\\n${isDescription ? escaped : indent(escaped)}\\n\"\"\"`;\n}\nconst printDocASTReducer = {\n  Name: {\n    leave: node => node.value\n  },\n  Variable: {\n    leave: node => '$' + node.name\n  },\n  // Document\n  Document: {\n    leave: node => join(node.definitions, '\\n\\n')\n  },\n  OperationDefinition: {\n    leave: node => {\n      const varDefs = wrap('(', join(node.variableDefinitions, ', '), ')');\n      const prefix = join([node.operation, join([node.name, varDefs]), join(node.directives, ' ')], ' ');\n      // the query short form.\n      return prefix + ' ' + node.selectionSet;\n    }\n  },\n  VariableDefinition: {\n    leave: _ref => {\n      let {\n        variable,\n        type,\n        defaultValue,\n        directives\n      } = _ref;\n      return variable + ': ' + type + wrap(' = ', defaultValue) + wrap(' ', join(directives, ' '));\n    }\n  },\n  SelectionSet: {\n    leave: _ref2 => {\n      let {\n        selections\n      } = _ref2;\n      return block(selections);\n    }\n  },\n  Field: {\n    leave(_ref3) {\n      let {\n        alias,\n        name,\n        arguments: args,\n        directives,\n        selectionSet\n      } = _ref3;\n      const prefix = wrap('', alias, ': ') + name;\n      let argsLine = prefix + wrap('(', join(args, ', '), ')');\n      if (argsLine.length > MAX_LINE_LENGTH) {\n        argsLine = prefix + wrap('(\\n', indent(join(args, '\\n')), '\\n)');\n      }\n      return join([argsLine, join(directives, ' '), selectionSet], ' ');\n    }\n  },\n  Argument: {\n    leave: _ref4 => {\n      let {\n        name,\n        value\n      } = _ref4;\n      return name + ': ' + value;\n    }\n  },\n  // Fragments\n  FragmentSpread: {\n    leave: _ref5 => {\n      let {\n        name,\n        directives\n      } = _ref5;\n      return '...' + name + wrap(' ', join(directives, ' '));\n    }\n  },\n  InlineFragment: {\n    leave: _ref6 => {\n      let {\n        typeCondition,\n        directives,\n        selectionSet\n      } = _ref6;\n      return join(['...', wrap('on ', typeCondition), join(directives, ' '), selectionSet], ' ');\n    }\n  },\n  FragmentDefinition: {\n    leave: _ref7 => {\n      let {\n        name,\n        typeCondition,\n        variableDefinitions,\n        directives,\n        selectionSet\n      } = _ref7;\n      return (\n        // Note: fragment variable definitions are experimental and may be changed\n        // or removed in the future.\n        `fragment ${name}${wrap('(', join(variableDefinitions, ', '), ')')} ` + `on ${typeCondition} ${wrap('', join(directives, ' '), ' ')}` + selectionSet\n      );\n    }\n  },\n  // Value\n  IntValue: {\n    leave: _ref8 => {\n      let {\n        value\n      } = _ref8;\n      return value;\n    }\n  },\n  FloatValue: {\n    leave: _ref9 => {\n      let {\n        value\n      } = _ref9;\n      return value;\n    }\n  },\n  StringValue: {\n    leave: _ref10 => {\n      let {\n        value,\n        block: isBlockString\n      } = _ref10;\n      if (isBlockString) {\n        return printBlockString(value);\n      }\n      return JSON.stringify(value);\n    }\n  },\n  BooleanValue: {\n    leave: _ref11 => {\n      let {\n        value\n      } = _ref11;\n      return value ? 'true' : 'false';\n    }\n  },\n  NullValue: {\n    leave: () => 'null'\n  },\n  EnumValue: {\n    leave: _ref12 => {\n      let {\n        value\n      } = _ref12;\n      return value;\n    }\n  },\n  ListValue: {\n    leave: _ref13 => {\n      let {\n        values\n      } = _ref13;\n      return '[' + join(values, ', ') + ']';\n    }\n  },\n  ObjectValue: {\n    leave: _ref14 => {\n      let {\n        fields\n      } = _ref14;\n      return '{' + join(fields, ', ') + '}';\n    }\n  },\n  ObjectField: {\n    leave: _ref15 => {\n      let {\n        name,\n        value\n      } = _ref15;\n      return name + ': ' + value;\n    }\n  },\n  // Directive\n  Directive: {\n    leave: _ref16 => {\n      let {\n        name,\n        arguments: args\n      } = _ref16;\n      return '@' + name + wrap('(', join(args, ', '), ')');\n    }\n  },\n  // Type\n  NamedType: {\n    leave: _ref17 => {\n      let {\n        name\n      } = _ref17;\n      return name;\n    }\n  },\n  ListType: {\n    leave: _ref18 => {\n      let {\n        type\n      } = _ref18;\n      return '[' + type + ']';\n    }\n  },\n  NonNullType: {\n    leave: _ref19 => {\n      let {\n        type\n      } = _ref19;\n      return type + '!';\n    }\n  },\n  // Type System Definitions\n  SchemaDefinition: {\n    leave: _ref20 => {\n      let {\n        directives,\n        operationTypes\n      } = _ref20;\n      return join(['schema', join(directives, ' '), block(operationTypes)], ' ');\n    }\n  },\n  OperationTypeDefinition: {\n    leave: _ref21 => {\n      let {\n        operation,\n        type\n      } = _ref21;\n      return operation + ': ' + type;\n    }\n  },\n  ScalarTypeDefinition: {\n    leave: _ref22 => {\n      let {\n        name,\n        directives\n      } = _ref22;\n      return join(['scalar', name, join(directives, ' ')], ' ');\n    }\n  },\n  ObjectTypeDefinition: {\n    leave: _ref23 => {\n      let {\n        name,\n        interfaces,\n        directives,\n        fields\n      } = _ref23;\n      return join(['type', name, wrap('implements ', join(interfaces, ' & ')), join(directives, ' '), block(fields)], ' ');\n    }\n  },\n  FieldDefinition: {\n    leave: _ref24 => {\n      let {\n        name,\n        arguments: args,\n        type,\n        directives\n      } = _ref24;\n      return name + (hasMultilineItems(args) ? wrap('(\\n', indent(join(args, '\\n')), '\\n)') : wrap('(', join(args, ', '), ')')) + ': ' + type + wrap(' ', join(directives, ' '));\n    }\n  },\n  InputValueDefinition: {\n    leave: _ref25 => {\n      let {\n        name,\n        type,\n        defaultValue,\n        directives\n      } = _ref25;\n      return join([name + ': ' + type, wrap('= ', defaultValue), join(directives, ' ')], ' ');\n    }\n  },\n  InterfaceTypeDefinition: {\n    leave: _ref26 => {\n      let {\n        name,\n        interfaces,\n        directives,\n        fields\n      } = _ref26;\n      return join(['interface', name, wrap('implements ', join(interfaces, ' & ')), join(directives, ' '), block(fields)], ' ');\n    }\n  },\n  UnionTypeDefinition: {\n    leave: _ref27 => {\n      let {\n        name,\n        directives,\n        types\n      } = _ref27;\n      return join(['union', name, join(directives, ' '), wrap('= ', join(types, ' | '))], ' ');\n    }\n  },\n  EnumTypeDefinition: {\n    leave: _ref28 => {\n      let {\n        name,\n        directives,\n        values\n      } = _ref28;\n      return join(['enum', name, join(directives, ' '), block(values)], ' ');\n    }\n  },\n  EnumValueDefinition: {\n    leave: _ref29 => {\n      let {\n        name,\n        directives\n      } = _ref29;\n      return join([name, join(directives, ' ')], ' ');\n    }\n  },\n  InputObjectTypeDefinition: {\n    leave: _ref30 => {\n      let {\n        name,\n        directives,\n        fields\n      } = _ref30;\n      return join(['input', name, join(directives, ' '), block(fields)], ' ');\n    }\n  },\n  DirectiveDefinition: {\n    leave: _ref31 => {\n      let {\n        name,\n        arguments: args,\n        repeatable,\n        locations\n      } = _ref31;\n      return 'directive @' + name + (hasMultilineItems(args) ? wrap('(\\n', indent(join(args, '\\n')), '\\n)') : wrap('(', join(args, ', '), ')')) + (repeatable ? ' repeatable' : '') + ' on ' + join(locations, ' | ');\n    }\n  },\n  SchemaExtension: {\n    leave: _ref32 => {\n      let {\n        directives,\n        operationTypes\n      } = _ref32;\n      return join(['extend schema', join(directives, ' '), block(operationTypes)], ' ');\n    }\n  },\n  ScalarTypeExtension: {\n    leave: _ref33 => {\n      let {\n        name,\n        directives\n      } = _ref33;\n      return join(['extend scalar', name, join(directives, ' ')], ' ');\n    }\n  },\n  ObjectTypeExtension: {\n    leave: _ref34 => {\n      let {\n        name,\n        interfaces,\n        directives,\n        fields\n      } = _ref34;\n      return join(['extend type', name, wrap('implements ', join(interfaces, ' & ')), join(directives, ' '), block(fields)], ' ');\n    }\n  },\n  InterfaceTypeExtension: {\n    leave: _ref35 => {\n      let {\n        name,\n        interfaces,\n        directives,\n        fields\n      } = _ref35;\n      return join(['extend interface', name, wrap('implements ', join(interfaces, ' & ')), join(directives, ' '), block(fields)], ' ');\n    }\n  },\n  UnionTypeExtension: {\n    leave: _ref36 => {\n      let {\n        name,\n        directives,\n        types\n      } = _ref36;\n      return join(['extend union', name, join(directives, ' '), wrap('= ', join(types, ' | '))], ' ');\n    }\n  },\n  EnumTypeExtension: {\n    leave: _ref37 => {\n      let {\n        name,\n        directives,\n        values\n      } = _ref37;\n      return join(['extend enum', name, join(directives, ' '), block(values)], ' ');\n    }\n  },\n  InputObjectTypeExtension: {\n    leave: _ref38 => {\n      let {\n        name,\n        directives,\n        fields\n      } = _ref38;\n      return join(['extend input', name, join(directives, ' '), block(fields)], ' ');\n    }\n  }\n};\nconst printDocASTReducerWithComments = Object.keys(printDocASTReducer).reduce((prev, key) => ({\n  ...prev,\n  [key]: {\n    leave: addDescription(printDocASTReducer[key].leave)\n  }\n}), {});\n/**\n * Converts an AST into a string, using one set of reasonable\n * formatting rules.\n */\nfunction printWithComments(ast) {\n  return (0, graphql_1.visit)(ast, printDocASTReducerWithComments);\n}\nexports.printWithComments = printWithComments;\nfunction isFieldDefinitionNode(node) {\n  return node.kind === 'FieldDefinition';\n}\n// graphql < v13 and > v15 does not export getDescription\nfunction getDescription(node, options) {\n  if (node.description != null) {\n    return node.description.value;\n  }\n  if (options === null || options === void 0 ? void 0 : options.commentDescriptions) {\n    return getComment(node);\n  }\n}\nexports.getDescription = getDescription;\nfunction getComment(node) {\n  const rawValue = getLeadingCommentBlock(node);\n  if (rawValue !== undefined) {\n    return dedentBlockStringValue(`\\n${rawValue}`);\n  }\n}\nexports.getComment = getComment;\nfunction getLeadingCommentBlock(node) {\n  const loc = node.loc;\n  if (!loc) {\n    return;\n  }\n  const comments = [];\n  let token = loc.startToken.prev;\n  while (token != null && token.kind === graphql_1.TokenKind.COMMENT && token.next != null && token.prev != null && token.line + 1 === token.next.line && token.line !== token.prev.line) {\n    const value = String(token.value);\n    comments.push(value);\n    token = token.prev;\n  }\n  return comments.length > 0 ? comments.reverse().join('\\n') : undefined;\n}\nexports.getLeadingCommentBlock = getLeadingCommentBlock;\nfunction dedentBlockStringValue(rawString) {\n  // Expand a block string's raw value into independent lines.\n  const lines = rawString.split(/\\r\\n|[\\n\\r]/g);\n  // Remove common indentation from all lines but first.\n  const commonIndent = getBlockStringIndentation(lines);\n  if (commonIndent !== 0) {\n    for (let i = 1; i < lines.length; i++) {\n      lines[i] = lines[i].slice(commonIndent);\n    }\n  }\n  // Remove leading and trailing blank lines.\n  while (lines.length > 0 && isBlank(lines[0])) {\n    lines.shift();\n  }\n  while (lines.length > 0 && isBlank(lines[lines.length - 1])) {\n    lines.pop();\n  }\n  // Return a string of the lines joined with U+000A.\n  return lines.join('\\n');\n}\nexports.dedentBlockStringValue = dedentBlockStringValue;\n/**\n * @internal\n */\nfunction getBlockStringIndentation(lines) {\n  let commonIndent = null;\n  for (let i = 1; i < lines.length; i++) {\n    const line = lines[i];\n    const indent = leadingWhitespace(line);\n    if (indent === line.length) {\n      continue; // skip empty lines\n    }\n\n    if (commonIndent === null || indent < commonIndent) {\n      commonIndent = indent;\n      if (commonIndent === 0) {\n        break;\n      }\n    }\n  }\n  return commonIndent === null ? 0 : commonIndent;\n}\nexports.getBlockStringIndentation = getBlockStringIndentation;\nfunction leadingWhitespace(str) {\n  let i = 0;\n  while (i < str.length && (str[i] === ' ' || str[i] === '\\t')) {\n    i++;\n  }\n  return i;\n}\nfunction isBlank(str) {\n  return leadingWhitespace(str) === str.length;\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","getBlockStringIndentation","dedentBlockStringValue","getLeadingCommentBlock","getComment","getDescription","printWithComments","printComment","pushComment","collectComment","resetComments","graphql_1","require","MAX_LINE_LENGTH","commentsRegistry","node","_a","entityName","name","kind","values","fields","field","isFieldDefinitionNode","arguments","arg","entity","argument","comment","length","keys","push","path","join","replace","maybeArray","separator","filter","x","hasMultilineItems","some","str","includes","addDescription","cb","_key","_parent","ancestors","parent","reduce","prev","key","Boolean","items","map","description","indent","maybeString","block","array","wrap","start","end","printBlockString","isDescription","undefined","escaped","indexOf","printDocASTReducer","Name","leave","Variable","Document","definitions","OperationDefinition","varDefs","variableDefinitions","prefix","operation","directives","selectionSet","VariableDefinition","_ref","variable","type","defaultValue","SelectionSet","_ref2","selections","Field","_ref3","alias","args","argsLine","Argument","_ref4","FragmentSpread","_ref5","InlineFragment","_ref6","typeCondition","FragmentDefinition","_ref7","IntValue","_ref8","FloatValue","_ref9","StringValue","_ref10","isBlockString","JSON","stringify","BooleanValue","_ref11","NullValue","EnumValue","_ref12","ListValue","_ref13","ObjectValue","_ref14","ObjectField","_ref15","Directive","_ref16","NamedType","_ref17","ListType","_ref18","NonNullType","_ref19","SchemaDefinition","_ref20","operationTypes","OperationTypeDefinition","_ref21","ScalarTypeDefinition","_ref22","ObjectTypeDefinition","_ref23","interfaces","FieldDefinition","_ref24","InputValueDefinition","_ref25","InterfaceTypeDefinition","_ref26","UnionTypeDefinition","_ref27","types","EnumTypeDefinition","_ref28","EnumValueDefinition","_ref29","InputObjectTypeDefinition","_ref30","DirectiveDefinition","_ref31","repeatable","locations","SchemaExtension","_ref32","ScalarTypeExtension","_ref33","ObjectTypeExtension","_ref34","InterfaceTypeExtension","_ref35","UnionTypeExtension","_ref36","EnumTypeExtension","_ref37","InputObjectTypeExtension","_ref38","printDocASTReducerWithComments","ast","visit","options","commentDescriptions","rawValue","loc","comments","token","startToken","TokenKind","COMMENT","next","line","String","reverse","rawString","lines","split","commonIndent","i","slice","isBlank","shift","pop","leadingWhitespace"],"sources":["/Users/chadward/node_modules/@graphql-tools/merge/node_modules/@graphql-tools/utils/cjs/comments.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getBlockStringIndentation = exports.dedentBlockStringValue = exports.getLeadingCommentBlock = exports.getComment = exports.getDescription = exports.printWithComments = exports.printComment = exports.pushComment = exports.collectComment = exports.resetComments = void 0;\nconst graphql_1 = require(\"graphql\");\nconst MAX_LINE_LENGTH = 80;\nlet commentsRegistry = {};\nfunction resetComments() {\n    commentsRegistry = {};\n}\nexports.resetComments = resetComments;\nfunction collectComment(node) {\n    var _a;\n    const entityName = (_a = node.name) === null || _a === void 0 ? void 0 : _a.value;\n    if (entityName == null) {\n        return;\n    }\n    pushComment(node, entityName);\n    switch (node.kind) {\n        case 'EnumTypeDefinition':\n            if (node.values) {\n                for (const value of node.values) {\n                    pushComment(value, entityName, value.name.value);\n                }\n            }\n            break;\n        case 'ObjectTypeDefinition':\n        case 'InputObjectTypeDefinition':\n        case 'InterfaceTypeDefinition':\n            if (node.fields) {\n                for (const field of node.fields) {\n                    pushComment(field, entityName, field.name.value);\n                    if (isFieldDefinitionNode(field) && field.arguments) {\n                        for (const arg of field.arguments) {\n                            pushComment(arg, entityName, field.name.value, arg.name.value);\n                        }\n                    }\n                }\n            }\n            break;\n    }\n}\nexports.collectComment = collectComment;\nfunction pushComment(node, entity, field, argument) {\n    const comment = getComment(node);\n    if (typeof comment !== 'string' || comment.length === 0) {\n        return;\n    }\n    const keys = [entity];\n    if (field) {\n        keys.push(field);\n        if (argument) {\n            keys.push(argument);\n        }\n    }\n    const path = keys.join('.');\n    if (!commentsRegistry[path]) {\n        commentsRegistry[path] = [];\n    }\n    commentsRegistry[path].push(comment);\n}\nexports.pushComment = pushComment;\nfunction printComment(comment) {\n    return '\\n# ' + comment.replace(/\\n/g, '\\n# ');\n}\nexports.printComment = printComment;\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n/**\n * NOTE: ==> This file has been modified just to add comments to the printed AST\n * This is a temp measure, we will move to using the original non modified printer.js ASAP.\n */\n/**\n * Given maybeArray, print an empty string if it is null or empty, otherwise\n * print all items together separated by separator if provided\n */\nfunction join(maybeArray, separator) {\n    return maybeArray ? maybeArray.filter(x => x).join(separator || '') : '';\n}\nfunction hasMultilineItems(maybeArray) {\n    var _a;\n    return (_a = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.some(str => str.includes('\\n'))) !== null && _a !== void 0 ? _a : false;\n}\nfunction addDescription(cb) {\n    return (node, _key, _parent, path, ancestors) => {\n        var _a;\n        const keys = [];\n        const parent = path.reduce((prev, key) => {\n            if (['fields', 'arguments', 'values'].includes(key) && prev.name) {\n                keys.push(prev.name.value);\n            }\n            return prev[key];\n        }, ancestors[0]);\n        const key = [...keys, (_a = parent === null || parent === void 0 ? void 0 : parent.name) === null || _a === void 0 ? void 0 : _a.value].filter(Boolean).join('.');\n        const items = [];\n        if (node.kind.includes('Definition') && commentsRegistry[key]) {\n            items.push(...commentsRegistry[key]);\n        }\n        return join([...items.map(printComment), node.description, cb(node, _key, _parent, path, ancestors)], '\\n');\n    };\n}\nfunction indent(maybeString) {\n    return maybeString && `  ${maybeString.replace(/\\n/g, '\\n  ')}`;\n}\n/**\n * Given array, print each item on its own line, wrapped in an\n * indented \"{ }\" block.\n */\nfunction block(array) {\n    return array && array.length !== 0 ? `{\\n${indent(join(array, '\\n'))}\\n}` : '';\n}\n/**\n * If maybeString is not null or empty, then wrap with start and end, otherwise\n * print an empty string.\n */\nfunction wrap(start, maybeString, end) {\n    return maybeString ? start + maybeString + (end || '') : '';\n}\n/**\n * Print a block string in the indented block form by adding a leading and\n * trailing blank line. However, if a block string starts with whitespace and is\n * a single-line, adding a leading blank line would strip that whitespace.\n */\nfunction printBlockString(value, isDescription = false) {\n    const escaped = value.replace(/\"\"\"/g, '\\\\\"\"\"');\n    return (value[0] === ' ' || value[0] === '\\t') && value.indexOf('\\n') === -1\n        ? `\"\"\"${escaped.replace(/\"$/, '\"\\n')}\"\"\"`\n        : `\"\"\"\\n${isDescription ? escaped : indent(escaped)}\\n\"\"\"`;\n}\nconst printDocASTReducer = {\n    Name: { leave: node => node.value },\n    Variable: { leave: node => '$' + node.name },\n    // Document\n    Document: {\n        leave: node => join(node.definitions, '\\n\\n'),\n    },\n    OperationDefinition: {\n        leave: node => {\n            const varDefs = wrap('(', join(node.variableDefinitions, ', '), ')');\n            const prefix = join([node.operation, join([node.name, varDefs]), join(node.directives, ' ')], ' ');\n            // the query short form.\n            return prefix + ' ' + node.selectionSet;\n        },\n    },\n    VariableDefinition: {\n        leave: ({ variable, type, defaultValue, directives }) => variable + ': ' + type + wrap(' = ', defaultValue) + wrap(' ', join(directives, ' ')),\n    },\n    SelectionSet: { leave: ({ selections }) => block(selections) },\n    Field: {\n        leave({ alias, name, arguments: args, directives, selectionSet }) {\n            const prefix = wrap('', alias, ': ') + name;\n            let argsLine = prefix + wrap('(', join(args, ', '), ')');\n            if (argsLine.length > MAX_LINE_LENGTH) {\n                argsLine = prefix + wrap('(\\n', indent(join(args, '\\n')), '\\n)');\n            }\n            return join([argsLine, join(directives, ' '), selectionSet], ' ');\n        },\n    },\n    Argument: { leave: ({ name, value }) => name + ': ' + value },\n    // Fragments\n    FragmentSpread: {\n        leave: ({ name, directives }) => '...' + name + wrap(' ', join(directives, ' ')),\n    },\n    InlineFragment: {\n        leave: ({ typeCondition, directives, selectionSet }) => join(['...', wrap('on ', typeCondition), join(directives, ' '), selectionSet], ' '),\n    },\n    FragmentDefinition: {\n        leave: ({ name, typeCondition, variableDefinitions, directives, selectionSet }) => \n        // Note: fragment variable definitions are experimental and may be changed\n        // or removed in the future.\n        `fragment ${name}${wrap('(', join(variableDefinitions, ', '), ')')} ` +\n            `on ${typeCondition} ${wrap('', join(directives, ' '), ' ')}` +\n            selectionSet,\n    },\n    // Value\n    IntValue: { leave: ({ value }) => value },\n    FloatValue: { leave: ({ value }) => value },\n    StringValue: {\n        leave: ({ value, block: isBlockString }) => {\n            if (isBlockString) {\n                return printBlockString(value);\n            }\n            return JSON.stringify(value);\n        },\n    },\n    BooleanValue: { leave: ({ value }) => (value ? 'true' : 'false') },\n    NullValue: { leave: () => 'null' },\n    EnumValue: { leave: ({ value }) => value },\n    ListValue: { leave: ({ values }) => '[' + join(values, ', ') + ']' },\n    ObjectValue: { leave: ({ fields }) => '{' + join(fields, ', ') + '}' },\n    ObjectField: { leave: ({ name, value }) => name + ': ' + value },\n    // Directive\n    Directive: {\n        leave: ({ name, arguments: args }) => '@' + name + wrap('(', join(args, ', '), ')'),\n    },\n    // Type\n    NamedType: { leave: ({ name }) => name },\n    ListType: { leave: ({ type }) => '[' + type + ']' },\n    NonNullType: { leave: ({ type }) => type + '!' },\n    // Type System Definitions\n    SchemaDefinition: {\n        leave: ({ directives, operationTypes }) => join(['schema', join(directives, ' '), block(operationTypes)], ' '),\n    },\n    OperationTypeDefinition: {\n        leave: ({ operation, type }) => operation + ': ' + type,\n    },\n    ScalarTypeDefinition: {\n        leave: ({ name, directives }) => join(['scalar', name, join(directives, ' ')], ' '),\n    },\n    ObjectTypeDefinition: {\n        leave: ({ name, interfaces, directives, fields }) => join(['type', name, wrap('implements ', join(interfaces, ' & ')), join(directives, ' '), block(fields)], ' '),\n    },\n    FieldDefinition: {\n        leave: ({ name, arguments: args, type, directives }) => name +\n            (hasMultilineItems(args)\n                ? wrap('(\\n', indent(join(args, '\\n')), '\\n)')\n                : wrap('(', join(args, ', '), ')')) +\n            ': ' +\n            type +\n            wrap(' ', join(directives, ' ')),\n    },\n    InputValueDefinition: {\n        leave: ({ name, type, defaultValue, directives }) => join([name + ': ' + type, wrap('= ', defaultValue), join(directives, ' ')], ' '),\n    },\n    InterfaceTypeDefinition: {\n        leave: ({ name, interfaces, directives, fields }) => join(['interface', name, wrap('implements ', join(interfaces, ' & ')), join(directives, ' '), block(fields)], ' '),\n    },\n    UnionTypeDefinition: {\n        leave: ({ name, directives, types }) => join(['union', name, join(directives, ' '), wrap('= ', join(types, ' | '))], ' '),\n    },\n    EnumTypeDefinition: {\n        leave: ({ name, directives, values }) => join(['enum', name, join(directives, ' '), block(values)], ' '),\n    },\n    EnumValueDefinition: {\n        leave: ({ name, directives }) => join([name, join(directives, ' ')], ' '),\n    },\n    InputObjectTypeDefinition: {\n        leave: ({ name, directives, fields }) => join(['input', name, join(directives, ' '), block(fields)], ' '),\n    },\n    DirectiveDefinition: {\n        leave: ({ name, arguments: args, repeatable, locations }) => 'directive @' +\n            name +\n            (hasMultilineItems(args)\n                ? wrap('(\\n', indent(join(args, '\\n')), '\\n)')\n                : wrap('(', join(args, ', '), ')')) +\n            (repeatable ? ' repeatable' : '') +\n            ' on ' +\n            join(locations, ' | '),\n    },\n    SchemaExtension: {\n        leave: ({ directives, operationTypes }) => join(['extend schema', join(directives, ' '), block(operationTypes)], ' '),\n    },\n    ScalarTypeExtension: {\n        leave: ({ name, directives }) => join(['extend scalar', name, join(directives, ' ')], ' '),\n    },\n    ObjectTypeExtension: {\n        leave: ({ name, interfaces, directives, fields }) => join(['extend type', name, wrap('implements ', join(interfaces, ' & ')), join(directives, ' '), block(fields)], ' '),\n    },\n    InterfaceTypeExtension: {\n        leave: ({ name, interfaces, directives, fields }) => join(['extend interface', name, wrap('implements ', join(interfaces, ' & ')), join(directives, ' '), block(fields)], ' '),\n    },\n    UnionTypeExtension: {\n        leave: ({ name, directives, types }) => join(['extend union', name, join(directives, ' '), wrap('= ', join(types, ' | '))], ' '),\n    },\n    EnumTypeExtension: {\n        leave: ({ name, directives, values }) => join(['extend enum', name, join(directives, ' '), block(values)], ' '),\n    },\n    InputObjectTypeExtension: {\n        leave: ({ name, directives, fields }) => join(['extend input', name, join(directives, ' '), block(fields)], ' '),\n    },\n};\nconst printDocASTReducerWithComments = Object.keys(printDocASTReducer).reduce((prev, key) => ({\n    ...prev,\n    [key]: {\n        leave: addDescription(printDocASTReducer[key].leave),\n    },\n}), {});\n/**\n * Converts an AST into a string, using one set of reasonable\n * formatting rules.\n */\nfunction printWithComments(ast) {\n    return (0, graphql_1.visit)(ast, printDocASTReducerWithComments);\n}\nexports.printWithComments = printWithComments;\nfunction isFieldDefinitionNode(node) {\n    return node.kind === 'FieldDefinition';\n}\n// graphql < v13 and > v15 does not export getDescription\nfunction getDescription(node, options) {\n    if (node.description != null) {\n        return node.description.value;\n    }\n    if (options === null || options === void 0 ? void 0 : options.commentDescriptions) {\n        return getComment(node);\n    }\n}\nexports.getDescription = getDescription;\nfunction getComment(node) {\n    const rawValue = getLeadingCommentBlock(node);\n    if (rawValue !== undefined) {\n        return dedentBlockStringValue(`\\n${rawValue}`);\n    }\n}\nexports.getComment = getComment;\nfunction getLeadingCommentBlock(node) {\n    const loc = node.loc;\n    if (!loc) {\n        return;\n    }\n    const comments = [];\n    let token = loc.startToken.prev;\n    while (token != null &&\n        token.kind === graphql_1.TokenKind.COMMENT &&\n        token.next != null &&\n        token.prev != null &&\n        token.line + 1 === token.next.line &&\n        token.line !== token.prev.line) {\n        const value = String(token.value);\n        comments.push(value);\n        token = token.prev;\n    }\n    return comments.length > 0 ? comments.reverse().join('\\n') : undefined;\n}\nexports.getLeadingCommentBlock = getLeadingCommentBlock;\nfunction dedentBlockStringValue(rawString) {\n    // Expand a block string's raw value into independent lines.\n    const lines = rawString.split(/\\r\\n|[\\n\\r]/g);\n    // Remove common indentation from all lines but first.\n    const commonIndent = getBlockStringIndentation(lines);\n    if (commonIndent !== 0) {\n        for (let i = 1; i < lines.length; i++) {\n            lines[i] = lines[i].slice(commonIndent);\n        }\n    }\n    // Remove leading and trailing blank lines.\n    while (lines.length > 0 && isBlank(lines[0])) {\n        lines.shift();\n    }\n    while (lines.length > 0 && isBlank(lines[lines.length - 1])) {\n        lines.pop();\n    }\n    // Return a string of the lines joined with U+000A.\n    return lines.join('\\n');\n}\nexports.dedentBlockStringValue = dedentBlockStringValue;\n/**\n * @internal\n */\nfunction getBlockStringIndentation(lines) {\n    let commonIndent = null;\n    for (let i = 1; i < lines.length; i++) {\n        const line = lines[i];\n        const indent = leadingWhitespace(line);\n        if (indent === line.length) {\n            continue; // skip empty lines\n        }\n        if (commonIndent === null || indent < commonIndent) {\n            commonIndent = indent;\n            if (commonIndent === 0) {\n                break;\n            }\n        }\n    }\n    return commonIndent === null ? 0 : commonIndent;\n}\nexports.getBlockStringIndentation = getBlockStringIndentation;\nfunction leadingWhitespace(str) {\n    let i = 0;\n    while (i < str.length && (str[i] === ' ' || str[i] === '\\t')) {\n        i++;\n    }\n    return i;\n}\nfunction isBlank(str) {\n    return leadingWhitespace(str) === str.length;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}